{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar group_1 = require(\"./scene/group\");\n\nvar selection_1 = require(\"./scene/selection\");\n\nvar line_1 = require(\"./scene/shape/line\");\n\nvar ticks_1 = require(\"./util/ticks\");\n\nvar angle_1 = require(\"./util/angle\");\n\nvar text_1 = require(\"./scene/shape/text\");\n\nvar arc_1 = require(\"./scene/shape/arc\");\n\nvar Tags;\n\n(function (Tags) {\n  Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n  Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\n\n\nvar Axis =\n/** @class */\nfunction () {\n  function Axis(scale) {\n    this.group = new group_1.Group();\n    this.line = new line_1.Line();\n    /**\n     * The horizontal translation of the axis group.\n     */\n\n    this.translationX = 0;\n    /**\n     * The vertical translation of the axis group.\n     */\n\n    this.translationY = 0;\n    /**\n     * Axis rotation angle in degrees.\n     */\n\n    this.rotation = 0;\n    /**\n     * The line width to be used by the axis line.\n     */\n\n    this.lineWidth = 1;\n    /**\n     * The color of the axis line.\n     * Use `null` rather than `rgba(0, 0, 0, 0)` to make the axis line invisible.\n     */\n\n    this.lineColor = 'rgba(195, 195, 195, 1)';\n    /**\n     * The line width to be used by axis ticks.\n     */\n\n    this.tickWidth = 1;\n    /**\n     * The line length to be used by axis ticks.\n     */\n\n    this.tickSize = 6;\n    /**\n     * The padding between the ticks and the labels.\n     */\n\n    this.tickPadding = 5;\n    /**\n     * The color of the axis ticks.\n     * Use `null` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n     */\n\n    this.tickColor = 'rgba(195, 195, 195, 1)';\n    /**\n     * The font to be used by the labels. The given font string should use the\n     * {@link https://www.w3.org/TR/CSS2/fonts.html#font-shorthand | font shorthand} notation.\n     */\n\n    this.labelFont = '12px Tahoma';\n    /**\n     * The color of the labels.\n     * Use `null` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n\n    this.labelColor = 'rgba(87, 87, 87, 1)';\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n     * (in degrees).\n     */\n\n    this._gridLength = 0;\n    /**\n     * The array of styles to cycle through when rendering grid lines.\n     * For example, use two {@link GridStyle} objects for alternating styles.\n     * Contains only one {@link GridStyle} object by default, meaning all grid lines\n     * have the same style.\n     */\n\n    this._gridStyle = [{\n      strokeStyle: 'rgba(219, 219, 219, 1)',\n      lineDash: [4, 2]\n    }];\n    /**\n     * `false` - render grid as lines of {@link gridLength} that extend the ticks\n     *           on the opposite side of the axis\n     * `true` - render grid as concentric circles that go through the ticks\n     */\n\n    this._radialGrid = false;\n    /**\n     * Custom label rotation in degrees.\n     * Labels are rendered perpendicular to the axis line by default.\n     * Or parallel to the axis line, if the {@link parallelLabels} is set to `true`.\n     * The value of this config is used as the angular offset/deflection\n     * from the default rotation.\n     */\n\n    this.labelRotation = 0;\n    /**\n     * By default labels and ticks are positioned to the left of the axis line.\n     * `true` positions the labels to the right of the axis line.\n     * However, if the axis is rotated, its easier to think in terms\n     * of this side or the opposite side, rather than left and right.\n     * We use the term `mirror` for conciseness, although it's not\n     * true mirroring - for example, when a label is rotated, so that\n     * it is inclined at the 45 degree angle, text flowing from north-west\n     * to south-east, ending at the tick to the left of the axis line,\n     * and then we set this config to `true`, the text will still be flowing\n     * from north-west to south-east, _starting_ at the tick to the right\n     * of the axis line.\n     */\n\n    this.mirrorLabels = false;\n    /**\n     * Labels are rendered perpendicular to the axis line by default.\n     * Setting this config to `true` makes labels render parallel to the axis line\n     * and center aligns labels' text at the ticks.\n     */\n\n    this.parallelLabels = false;\n    this.scale = scale;\n    this.groupSelection = selection_1.Selection.select(this.group).selectAll();\n    this.group.append(this.line);\n  }\n\n  Object.defineProperty(Axis.prototype, \"gridLength\", {\n    get: function get() {\n      return this._gridLength;\n    },\n    set: function set(value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"gridStyle\", {\n    get: function get() {\n      return this._gridStyle;\n    },\n    set: function set(value) {\n      if (value.length) {\n        this._gridStyle = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"radialGrid\", {\n    get: function get() {\n      return this._radialGrid;\n    },\n    set: function set(value) {\n      if (this._radialGrid !== value) {\n        this._radialGrid = value;\n        this.groupSelection = this.groupSelection.remove().setData([]);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called manually after changing any of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n\n  Axis.prototype.update = function () {\n    var _this = this;\n\n    var group = this.group;\n    var scale = this.scale;\n    var rotation = angle_1.toRadians(this.rotation);\n    var labelRotation = angle_1.normalizeAngle360(angle_1.toRadians(this.labelRotation));\n    group.translationX = this.translationX;\n    group.translationY = this.translationY;\n    group.rotation = rotation; // Render ticks and labels.\n\n    var ticks = scale.ticks(10);\n    var decimalDigits = 0;\n\n    if (ticks instanceof ticks_1.NumericTicks) {\n      decimalDigits = ticks.decimalDigits;\n    }\n\n    var bandwidth = (scale.bandwidth || 0) / 2; // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n\n    var sideFlag = this.mirrorLabels ? 1 : -1; // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, Ï€] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n\n    var parallelFlipRotation = angle_1.normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = angle_1.normalizeAngle360(rotation - Math.PI / 2); // Flip if the axis rotation angle is in the top hemisphere.\n\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n    var parallelLabels = this.parallelLabels;\n    var update = this.groupSelection.setData(ticks);\n    update.exit.remove();\n    var enter = update.enter.append(group_1.Group); // Line auto-snaps to pixel grid if vertical or horizontal.\n\n    enter.append(line_1.Line).each(function (node) {\n      return node.tag = Tags.Tick;\n    });\n\n    if (this.gridLength) {\n      if (this.radialGrid) {\n        enter.append(arc_1.Arc).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      } else {\n        enter.append(line_1.Line).each(function (node) {\n          return node.tag = Tags.GridLine;\n        });\n      }\n    }\n\n    enter.append(text_1.Text);\n    var groupSelection = update.merge(enter);\n    groupSelection.attrFn('translationY', function (node, datum) {\n      return Math.round(scale.convert(datum) + bandwidth);\n    });\n    groupSelection.selectByTag(Tags.Tick).each(function (line) {\n      line.lineWidth = _this.tickWidth;\n      line.strokeStyle = _this.tickColor;\n    }).attr('x1', sideFlag * this.tickSize).attr('x2', 0).attr('y1', 0).attr('y2', 0);\n\n    if (this.gridLength) {\n      var styles_1 = this.gridStyle;\n      var styleCount_1 = styles_1.length;\n      var gridLines = void 0;\n\n      if (this.radialGrid) {\n        var angularGridLength_1 = angle_1.normalizeAngle360Inclusive(angle_1.toRadians(this.gridLength));\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (arc, datum) {\n          var radius = Math.round(scale.convert(datum) + bandwidth);\n          arc.centerX = 0;\n          arc.centerY = _this.scale.range[0] - radius;\n          arc.endAngle = angularGridLength_1;\n          arc.radiusX = radius;\n          arc.radiusY = radius;\n        });\n      } else {\n        gridLines = groupSelection.selectByTag(Tags.GridLine).each(function (line) {\n          line.x1 = 0;\n          line.x2 = -sideFlag * _this.gridLength;\n          line.y1 = 0;\n          line.y2 = 0;\n          line.visible = line.parent.translationY !== scale.range[0];\n        });\n      }\n\n      gridLines.each(function (arc, datum, index) {\n        var style = styles_1[index % styleCount_1];\n        arc.strokeStyle = style.strokeStyle;\n        arc.lineDash = style.lineDash;\n        arc.fillStyle = null;\n      });\n    }\n\n    var labels = groupSelection.selectByClass(text_1.Text).each(function (label, datum) {\n      label.font = _this.labelFont;\n      label.fillStyle = _this.labelColor;\n      label.textBaseline = parallelLabels && !labelRotation ? sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom' : 'middle';\n      label.text = decimalDigits && typeof datum === 'number' ? datum.toFixed(decimalDigits) : datum.toString();\n      label.textAlign = parallelLabels ? labelRotation ? sideFlag * alignFlag === -1 ? 'end' : 'start' : 'center' : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n    });\n    var labelX = sideFlag * (this.tickSize + this.tickPadding);\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    labels.attr('x', labelX).attr('rotationCenterX', labelX).attr('rotation', autoRotation + labelRotation);\n    this.groupSelection = groupSelection; // Render axis line.\n\n    var line = this.line;\n    line.x1 = 0;\n    line.x2 = 0;\n    line.y1 = scale.range[0];\n    line.y2 = scale.range[scale.range.length - 1];\n    line.lineWidth = this.lineWidth;\n    line.strokeStyle = this.lineColor;\n  };\n\n  return Axis;\n}();\n\nexports.Axis = Axis;","map":null,"metadata":{},"sourceType":"script"}