{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar RangeController =\n/** @class */\nfunction () {\n  function RangeController() {\n    this.bodyScrollListener = this.onBodyScroll.bind(this);\n    this.dragging = false;\n  }\n\n  RangeController.prototype.registerGridComp = function (gridPanel) {\n    this.gridPanel = gridPanel;\n    this.autoScrollService = new AutoScrollService(this.gridPanel, this.gridOptionsWrapper);\n  };\n\n  RangeController.prototype.init = function () {\n    this.logger = this.loggerFactory.create('RangeController');\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.clearSelection.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_GROUP_OPENED, this.clearSelection.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_MOVED, this.clearSelection.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_PINNED, this.clearSelection.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearSelection.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_VISIBLE, this.clearSelection.bind(this));\n  };\n\n  RangeController.prototype.setRangeToCell = function (cell, appendRange) {\n    if (appendRange === void 0) {\n      appendRange = false;\n    }\n\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    }\n\n    var columns = this.updateSelectedColumns(cell.column, cell.column);\n\n    if (!columns) {\n      return;\n    }\n\n    var gridCellDef = {\n      rowIndex: cell.rowIndex,\n      floating: cell.floating,\n      column: cell.column\n    };\n    var newRange = {\n      start: new ag_grid_community_1.GridCell(gridCellDef),\n      end: new ag_grid_community_1.GridCell(gridCellDef),\n      columns: columns\n    };\n    var suppressMultiRangeSelections = this.gridOptionsWrapper.isSuppressMultiRangeSelection(); // if not appending, then clear previous range selections\n\n    if (suppressMultiRangeSelections || !appendRange || ag_grid_community_1._.missing(this.cellRanges)) {\n      this.cellRanges = [];\n    }\n\n    if (this.cellRanges) {\n      this.cellRanges.push(newRange);\n    }\n\n    this.activeRange = null;\n    this.dispatchChangedEvent(true, false);\n  };\n\n  RangeController.prototype.extendRangeToCell = function (toCell) {\n    var lastRange = ag_grid_community_1._.existsAndNotEmpty(this.cellRanges) && this.cellRanges ? this.cellRanges[this.cellRanges.length - 1] : null;\n    var startCell = lastRange ? lastRange.start : toCell;\n    this.setRange({\n      rowStart: startCell.rowIndex,\n      floatingStart: startCell.floating,\n      rowEnd: toCell.rowIndex,\n      floatingEnd: toCell.floating,\n      columnStart: startCell.column,\n      columnEnd: toCell.column\n    });\n  }; // returns true if successful, false if not successful\n\n\n  RangeController.prototype.extendRangeInDirection = function (startCell, key) {\n    var oneRangeExists = ag_grid_community_1._.exists(this.cellRanges) && this.cellRanges || this.cellRanges && this.cellRanges.length === 1;\n    var previousSelectionStart = oneRangeExists && this.cellRanges ? this.cellRanges[0].start : null;\n    var takeEndFromPreviousSelection = startCell.equals(previousSelectionStart);\n    var previousEndCell = takeEndFromPreviousSelection && this.cellRanges ? this.cellRanges[0].end : startCell;\n    var newEndCell = this.cellNavigationService.getNextCellToFocus(key, previousEndCell); // if user is at end of grid, so no cell to extend to, we return false\n\n    if (!newEndCell) {\n      return false;\n    }\n\n    this.setRange({\n      rowStart: startCell.rowIndex,\n      floatingStart: startCell.floating,\n      rowEnd: newEndCell.rowIndex,\n      floatingEnd: newEndCell.floating,\n      columnStart: startCell.column,\n      columnEnd: newEndCell.column\n    });\n    return true;\n  };\n\n  RangeController.prototype.setRange = function (rangeSelection) {\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    }\n\n    this.cellRanges = [];\n    this.addRange(rangeSelection);\n  };\n\n  RangeController.prototype.addRange = function (rangeSelection) {\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    }\n\n    var columnStart = this.columnController.getColumnWithValidation(rangeSelection.columnStart);\n    var columnEnd = this.columnController.getPrimaryColumn(rangeSelection.columnEnd);\n\n    if (!columnStart || !columnEnd) {\n      return;\n    }\n\n    var columns = this.updateSelectedColumns(columnStart, columnEnd);\n\n    if (!columns) {\n      return;\n    }\n\n    var startGridCellDef = {\n      column: columnStart,\n      rowIndex: rangeSelection.rowStart,\n      floating: rangeSelection.floatingStart\n    };\n    var endGridCellDef = {\n      column: columnEnd,\n      rowIndex: rangeSelection.rowEnd,\n      floating: rangeSelection.floatingEnd\n    };\n    var newRange = {\n      start: new ag_grid_community_1.GridCell(startGridCellDef),\n      end: new ag_grid_community_1.GridCell(endGridCellDef),\n      columns: columns\n    };\n\n    if (!this.cellRanges) {\n      this.cellRanges = [];\n    }\n\n    this.cellRanges.push(newRange);\n    this.dispatchChangedEvent(true, false);\n  };\n\n  RangeController.prototype.getCellRanges = function () {\n    return this.cellRanges;\n  };\n\n  RangeController.prototype.isEmpty = function () {\n    return !this.cellRanges || ag_grid_community_1._.missingOrEmpty(this.cellRanges);\n  };\n\n  RangeController.prototype.isMoreThanOneCell = function () {\n    if (!this.cellRanges || ag_grid_community_1._.missingOrEmpty(this.cellRanges)) {\n      return false;\n    } else {\n      if (this.cellRanges.length > 1) {\n        return true;\n      } else {\n        var onlyRange = this.cellRanges[0];\n        var onlyOneCellInRange = onlyRange.start.column === onlyRange.end.column && onlyRange.start.rowIndex === onlyRange.end.rowIndex;\n        return !onlyOneCellInRange;\n      }\n    }\n  };\n\n  RangeController.prototype.clearSelection = function () {\n    if (ag_grid_community_1._.missing(this.cellRanges)) {\n      return;\n    }\n\n    this.activeRange = null;\n    this.cellRanges = null;\n    this.dispatchChangedEvent(true, false);\n  }; // as the user is dragging outside of the panel, the div starts to scroll, which in turn\n  // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate\n  // the selection my mimicking a new mouse event\n\n\n  RangeController.prototype.onBodyScroll = function () {\n    this.onDragging(this.lastMouseEvent);\n  };\n\n  RangeController.prototype.isCellInAnyRange = function (cell) {\n    return this.getCellRangeCount(cell) > 0;\n  };\n\n  RangeController.prototype.isCellInSpecificRange = function (cell, range) {\n    var columnInRange = range.columns !== null && range.columns.indexOf(cell.column) >= 0;\n    var rowInRange = this.isRowInRange(cell.rowIndex, cell.floating, range);\n    return columnInRange && rowInRange;\n  }; // returns the number of ranges this cell is in\n\n\n  RangeController.prototype.getCellRangeCount = function (cell) {\n    var _this = this;\n\n    if (!this.cellRanges || ag_grid_community_1._.missingOrEmpty(this.cellRanges)) {\n      return 0;\n    }\n\n    var matchingCount = 0;\n    this.cellRanges.forEach(function (cellRange) {\n      if (_this.isCellInSpecificRange(cell, cellRange)) {\n        matchingCount++;\n      }\n    });\n    return matchingCount;\n  };\n\n  RangeController.prototype.isRowInRange = function (rowIndex, floating, cellRange) {\n    var row1 = new ag_grid_community_1.GridRow(cellRange.start.rowIndex, cellRange.start.floating);\n    var row2 = new ag_grid_community_1.GridRow(cellRange.end.rowIndex, cellRange.end.floating);\n    var firstRow = row1.before(row2) ? row1 : row2;\n    var lastRow = row1.before(row2) ? row2 : row1;\n    var thisRow = new ag_grid_community_1.GridRow(rowIndex, floating);\n\n    if (thisRow.equals(firstRow) || thisRow.equals(lastRow)) {\n      return true;\n    } else {\n      var afterFirstRow = !thisRow.before(firstRow);\n      var beforeLastRow = thisRow.before(lastRow);\n      return afterFirstRow && beforeLastRow;\n    }\n  };\n\n  RangeController.prototype.onDragStart = function (mouseEvent) {\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    } // ctrlKey for windows, metaKey for Apple\n\n\n    var multiKeyPressed = mouseEvent.ctrlKey || mouseEvent.metaKey;\n    var allowMulti = !this.gridOptionsWrapper.isSuppressMultiRangeSelection();\n    var multiSelectKeyPressed = allowMulti ? multiKeyPressed : false;\n\n    var missingRanges = ag_grid_community_1._.missing(this.cellRanges);\n\n    var cell = this.mouseEventService.getGridCellForEvent(mouseEvent);\n\n    if (ag_grid_community_1._.missing(cell)) {\n      // if drag wasn't on cell, then do nothing, including do not set dragging=true,\n      // (which them means onDragging and onDragStop do nothing)\n      return;\n    }\n\n    var len = missingRanges || !this.cellRanges ? 0 : this.cellRanges.length;\n\n    if (missingRanges || !multiSelectKeyPressed) {\n      this.cellRanges = [];\n    } else if (!this.activeRange && len && this.cellRanges && this.isCellInSpecificRange(cell, this.cellRanges[len - 1])) {\n      this.activeRange = this.activeRange = this.cellRanges[len - 1];\n    }\n\n    if (!this.activeRange) {\n      this.createNewActiveRange(cell);\n    }\n\n    this.gridPanel.addScrollEventListener(this.bodyScrollListener);\n    this.dragging = true;\n\n    var _a = this.gridPanel.getFloatingTopBottom(),\n        eTop = _a[0],\n        eBottom = _a[1];\n\n    var target = mouseEvent.target;\n\n    if (eTop.contains(target)) {\n      this.startedFrom = 'top';\n    } else if (eBottom.contains(target)) {\n      this.startedFrom = 'bottom';\n    } else {\n      this.startedFrom = 'body';\n    }\n\n    this.lastMouseEvent = mouseEvent;\n    this.selectionChanged(false, true);\n  };\n\n  RangeController.prototype.createNewActiveRange = function (cell) {\n    var gridCellDef = {\n      column: cell.column,\n      rowIndex: cell.rowIndex,\n      floating: cell.floating\n    };\n    this.activeRange = {\n      start: new ag_grid_community_1.GridCell(gridCellDef),\n      end: new ag_grid_community_1.GridCell(gridCellDef),\n      columns: [cell.column]\n    };\n\n    if (this.cellRanges) {\n      this.cellRanges.push(this.activeRange);\n    }\n  };\n\n  RangeController.prototype.selectionChanged = function (finished, started) {\n    if (this.activeRange) {\n      this.activeRange.columns = this.updateSelectedColumns(this.activeRange.start.column, this.activeRange.end.column);\n    }\n\n    this.dispatchChangedEvent(finished, started);\n  };\n\n  RangeController.prototype.dispatchChangedEvent = function (finished, started) {\n    var event = {\n      type: ag_grid_community_1.Events.EVENT_RANGE_SELECTION_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      finished: finished,\n      started: started\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  RangeController.prototype.onDragStop = function () {\n    if (!this.dragging) {\n      return;\n    }\n\n    this.autoScrollService.ensureCleared();\n    this.gridPanel.removeScrollEventListener(this.bodyScrollListener);\n    this.lastMouseEvent = null;\n    this.dragging = false;\n    this.startedFrom = null;\n    this.dispatchChangedEvent(true, false);\n  };\n\n  RangeController.prototype.onDragging = function (mouseEvent) {\n    if (!this.dragging || !this.activeRange || !mouseEvent) {\n      return;\n    }\n\n    this.lastMouseEvent = mouseEvent;\n\n    var _a = this.gridPanel.getFloatingTopBottom(),\n        eTop = _a[0],\n        eBottom = _a[1];\n\n    var target = mouseEvent.target;\n    var skipVerticalScroll = false;\n\n    if (this.startedFrom === 'top' && eTop.contains(target) || this.startedFrom === 'bottom' && eBottom.contains(target)) {\n      skipVerticalScroll = true;\n    }\n\n    this.autoScrollService.check(mouseEvent, skipVerticalScroll);\n    var cell = this.mouseEventService.getGridCellForEvent(mouseEvent);\n\n    if (ag_grid_community_1._.missing(cell)) {\n      return;\n    }\n\n    var columnChanged = false;\n\n    if (cell.column !== this.activeRange.end.column) {\n      this.activeRange.end.column = cell.column;\n      columnChanged = true;\n    }\n\n    var rowChanged = false;\n\n    if (cell.rowIndex !== this.activeRange.end.rowIndex || cell.floating !== this.activeRange.end.floating) {\n      this.activeRange.end.rowIndex = cell.rowIndex;\n      this.activeRange.end.floating = cell.floating;\n      rowChanged = true;\n    }\n\n    if (columnChanged || rowChanged) {\n      this.selectionChanged(false, false);\n    }\n  };\n\n  RangeController.prototype.updateSelectedColumns = function (columnFrom, columnTo) {\n    var allColumns = this.columnController.getAllDisplayedColumns();\n    var fromIndex = allColumns.indexOf(columnFrom);\n    var toIndex = allColumns.indexOf(columnTo);\n\n    if (fromIndex < 0) {\n      console.warn('ag-Grid: column ' + columnFrom.getId() + ' is not visible');\n      return null;\n    }\n\n    if (toIndex < 0) {\n      console.warn('ag-Grid: column ' + columnTo.getId() + ' is not visible');\n      return null;\n    }\n\n    var firstIndex = Math.min(fromIndex, toIndex);\n    var lastIndex = Math.max(fromIndex, toIndex);\n    var columns = [];\n\n    for (var i = firstIndex; i <= lastIndex; i++) {\n      columns.push(allColumns[i]);\n    }\n\n    return columns;\n  };\n\n  __decorate([ag_grid_community_1.Autowired('loggerFactory'), __metadata(\"design:type\", ag_grid_community_1.LoggerFactory)], RangeController.prototype, \"loggerFactory\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rowModel'), __metadata(\"design:type\", Object)], RangeController.prototype, \"rowModel\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('eventService'), __metadata(\"design:type\", ag_grid_community_1.EventService)], RangeController.prototype, \"eventService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnController'), __metadata(\"design:type\", ag_grid_community_1.ColumnController)], RangeController.prototype, \"columnController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rowRenderer'), __metadata(\"design:type\", ag_grid_community_1.RowRenderer)], RangeController.prototype, \"rowRenderer\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('focusedCellController'), __metadata(\"design:type\", ag_grid_community_1.FocusedCellController)], RangeController.prototype, \"focusedCellController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('mouseEventService'), __metadata(\"design:type\", ag_grid_community_1.MouseEventService)], RangeController.prototype, \"mouseEventService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)], RangeController.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnApi'), __metadata(\"design:type\", ag_grid_community_1.ColumnApi)], RangeController.prototype, \"columnApi\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridApi'), __metadata(\"design:type\", ag_grid_community_1.GridApi)], RangeController.prototype, \"gridApi\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('cellNavigationService'), __metadata(\"design:type\", ag_grid_community_1.CellNavigationService)], RangeController.prototype, \"cellNavigationService\", void 0);\n\n  __decorate([ag_grid_community_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], RangeController.prototype, \"init\", null);\n\n  RangeController = __decorate([ag_grid_community_1.Bean('rangeController')], RangeController);\n  return RangeController;\n}();\n\nexports.RangeController = RangeController;\n\nvar AutoScrollService =\n/** @class */\nfunction () {\n  function AutoScrollService(gridPanel, gridOptionsWrapper) {\n    this.tickingInterval = null;\n    this.gridPanel = gridPanel;\n    this.gridOptionsWrapper = gridOptionsWrapper;\n  }\n\n  AutoScrollService.prototype.check = function (mouseEvent, skipVerticalScroll) {\n    if (skipVerticalScroll === void 0) {\n      skipVerticalScroll = false;\n    } // we don't do ticking if grid is auto height\n\n\n    if (this.gridOptionsWrapper.getDomLayout() !== ag_grid_community_1.Constants.DOM_LAYOUT_NORMAL) {\n      return;\n    }\n\n    var rect = this.gridPanel.getBodyClientRect();\n    this.tickLeft = mouseEvent.clientX < rect.left + 20;\n    this.tickRight = mouseEvent.clientX > rect.right - 20;\n    this.tickUp = mouseEvent.clientY < rect.top + 20 && !skipVerticalScroll;\n    this.tickDown = mouseEvent.clientY > rect.bottom - 20 && !skipVerticalScroll;\n\n    if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) {\n      this.ensureTickingStarted();\n    } else {\n      this.ensureCleared();\n    }\n  };\n\n  AutoScrollService.prototype.ensureTickingStarted = function () {\n    if (this.tickingInterval === null) {\n      this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);\n      this.tickCount = 0;\n    }\n  };\n\n  AutoScrollService.prototype.doTick = function () {\n    this.tickCount++;\n    var vScrollPosition = this.gridPanel.getVScrollPosition();\n    var hScrollPosition = this.gridPanel.getHScrollPosition();\n    var tickAmount;\n\n    if (this.tickCount > 20) {\n      tickAmount = 200;\n    } else if (this.tickCount > 10) {\n      tickAmount = 80;\n    } else {\n      tickAmount = 40;\n    }\n\n    if (this.tickUp) {\n      this.gridPanel.setVerticalScrollPosition(vScrollPosition.top - tickAmount);\n    }\n\n    if (this.tickDown) {\n      this.gridPanel.setVerticalScrollPosition(vScrollPosition.top + tickAmount);\n    }\n\n    if (this.tickLeft) {\n      this.gridPanel.setHorizontalScrollPosition(hScrollPosition.left - tickAmount);\n    }\n\n    if (this.tickRight) {\n      this.gridPanel.setHorizontalScrollPosition(hScrollPosition.left + tickAmount);\n    }\n  };\n\n  AutoScrollService.prototype.ensureCleared = function () {\n    if (this.tickingInterval) {\n      window.clearInterval(this.tickingInterval);\n      this.tickingInterval = null;\n    }\n  };\n\n  return AutoScrollService;\n}();","map":null,"metadata":{},"sourceType":"script"}