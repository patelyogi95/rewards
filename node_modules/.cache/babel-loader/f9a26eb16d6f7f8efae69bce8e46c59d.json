{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar rangeController_1 = require(\"./rangeController\");\n\nvar ClipboardService =\n/** @class */\nfunction () {\n  function ClipboardService() {}\n\n  ClipboardService.prototype.registerGridCore = function (gridCore) {\n    this.gridCore = gridCore;\n  };\n\n  ClipboardService.prototype.init = function () {\n    this.logger = this.loggerFactory.create('ClipboardService');\n  };\n\n  ClipboardService.prototype.pasteFromClipboard = function () {\n    var _this = this;\n\n    this.logger.log('pasteFromClipboard');\n    this.executeOnTempElement(function (textArea) {\n      textArea.focus();\n    }, function (element) {\n      var data = element.value;\n\n      if (ag_grid_community_1._.missingOrEmpty(data)) {\n        return;\n      }\n\n      var parsedData = _this.dataToArray(data);\n\n      var userFunc = _this.gridOptionsWrapper.getProcessDataFromClipboardFunc();\n\n      if (userFunc) {\n        parsedData = userFunc({\n          data: parsedData\n        });\n      }\n\n      if (ag_grid_community_1._.missingOrEmpty(parsedData)) {\n        return;\n      }\n\n      _this.eventService.dispatchEvent({\n        type: ag_grid_community_1.Events.EVENT_PASTE_START,\n        api: _this.gridOptionsWrapper.getApi(),\n        columnApi: _this.gridOptionsWrapper.getColumnApi(),\n        source: 'clipboard'\n      });\n\n      var singleCellInClipboard = parsedData.length == 1 && parsedData[0].length == 1;\n      _this.rangeController.isMoreThanOneCell() && !singleCellInClipboard ? _this.pasteToRange(parsedData) : _this.pasteToSingleCell(parsedData);\n\n      _this.eventService.dispatchEvent({\n        type: ag_grid_community_1.Events.EVENT_PASTE_END,\n        api: _this.gridOptionsWrapper.getApi(),\n        columnApi: _this.gridOptionsWrapper.getColumnApi(),\n        source: 'clipboard'\n      });\n    });\n  };\n\n  ClipboardService.prototype.pasteToRange = function (clipboardData) {\n    var _this = this;\n\n    var cellsToFlash = {};\n    var updatedRowNodes = [];\n    var updatedColumnIds = []; // true if clipboard data can be evenly pasted into range, otherwise false\n\n    var abortRepeatingPasteIntoRows = this.rangeSize() % clipboardData.length != 0;\n    var indexOffset = 0,\n        dataRowIndex = 0;\n\n    var rowCallback = function rowCallback(currentRow, rowNode, columns, index, isLastRow) {\n      var atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n\n      if (atEndOfClipboardData) {\n        if (abortRepeatingPasteIntoRows) {\n          return;\n        } // increment offset and reset data index to repeat paste of data\n\n\n        indexOffset += dataRowIndex;\n        dataRowIndex = 0;\n      }\n\n      var currentRowData = clipboardData[index - indexOffset]; // otherwise we are not the first row, so copy\n\n      updatedRowNodes.push(rowNode);\n      columns.forEach(function (column, idx) {\n        if (!column.isCellEditable(rowNode)) {\n          return;\n        } // repeat data for columns we don't have data for - happens when to range is bigger than copied data range\n\n\n        if (idx >= currentRowData.length) {\n          idx = idx % currentRowData.length;\n        }\n\n        var firstRowValue = currentRowData[idx];\n\n        var processCellFromClipboardFunc = _this.gridOptionsWrapper.getProcessCellFromClipboardFunc();\n\n        firstRowValue = _this.userProcessCell(rowNode, column, firstRowValue, processCellFromClipboardFunc, ag_grid_community_1.Constants.EXPORT_TYPE_DRAG_COPY);\n\n        _this.valueService.setValue(rowNode, column, firstRowValue);\n\n        var gridCellDef = {\n          rowIndex: currentRow.rowIndex,\n          floating: currentRow.floating,\n          column: column\n        };\n        var cellId = new ag_grid_community_1.GridCell(gridCellDef).createId();\n        cellsToFlash[cellId] = true;\n      });\n      ++dataRowIndex;\n    };\n\n    this.iterateActiveRanges(false, rowCallback);\n    this.rowRenderer.refreshCells({\n      rowNodes: updatedRowNodes,\n      columns: updatedColumnIds\n    });\n    this.dispatchFlashCells(cellsToFlash);\n    this.fireRowChanged(updatedRowNodes);\n  };\n\n  ClipboardService.prototype.pasteToSingleCell = function (parsedData) {\n    var focusedCell = this.focusedCellController.getFocusedCell();\n\n    if (!focusedCell) {\n      return;\n    } // remove last row if empty, excel puts empty last row in\n\n\n    var lastLine = parsedData[parsedData.length - 1];\n\n    if (lastLine.length === 1 && lastLine[0] === '') {\n      ag_grid_community_1._.removeFromArray(parsedData, lastLine);\n    }\n\n    var currentRow = new ag_grid_community_1.GridRow(focusedCell.rowIndex, focusedCell.floating);\n    var cellsToFlash = {};\n    var updatedRowNodes = [];\n    var updatedColumnIds = [];\n    var columnsToPasteInto = this.columnController.getDisplayedColumnsStartingAt(focusedCell.column);\n    var onlyOneCellInRange = parsedData.length === 1 && parsedData[0].length === 1;\n\n    if (onlyOneCellInRange) {\n      this.singleCellRange(parsedData, updatedRowNodes, currentRow, cellsToFlash, updatedColumnIds);\n    } else {\n      this.multipleCellRange(parsedData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, updatedColumnIds, ag_grid_community_1.Constants.EXPORT_TYPE_CLIPBOARD);\n    } // this is very heavy, should possibly just refresh the specific cells?\n\n\n    this.rowRenderer.refreshCells({\n      rowNodes: updatedRowNodes,\n      columns: updatedColumnIds\n    });\n    this.dispatchFlashCells(cellsToFlash);\n    this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);\n    this.fireRowChanged(updatedRowNodes);\n  };\n\n  ClipboardService.prototype.copyRangeDown = function () {\n    var _this = this;\n\n    if (this.rangeController.isEmpty()) {\n      return;\n    }\n\n    this.eventService.dispatchEvent({\n      type: ag_grid_community_1.Events.EVENT_PASTE_START,\n      api: this.gridOptionsWrapper.getApi(),\n      columnApi: this.gridOptionsWrapper.getColumnApi(),\n      source: 'rangeDown'\n    });\n    var cellsToFlash = {};\n    var firstRowValues = [];\n    var updatedRowNodes = [];\n    var updatedColumnIds = [];\n\n    var rowCallback = function rowCallback(currentRow, rowNode, columns, index, isLastRow) {\n      // take reference of first row, this is the one we will be using to copy from\n      if (!firstRowValues.length) {\n        // two reasons for looping through columns\n        columns.forEach(function (column) {\n          // reason 1 - to get the initial values to copy down\n          var value = _this.valueService.getValue(column, rowNode);\n\n          var processCellForClipboardFunc = _this.gridOptionsWrapper.getProcessCellForClipboardFunc();\n\n          value = _this.userProcessCell(rowNode, column, value, processCellForClipboardFunc, ag_grid_community_1.Constants.EXPORT_TYPE_DRAG_COPY);\n          firstRowValues.push(value); // reason 2 - to record the columnId for refreshing\n\n          updatedColumnIds.push(column.getId());\n        });\n      } else {\n        // otherwise we are not the first row, so copy\n        updatedRowNodes.push(rowNode);\n        columns.forEach(function (column, index) {\n          if (!column.isCellEditable(rowNode)) {\n            return;\n          }\n\n          var firstRowValue = firstRowValues[index];\n\n          var processCellFromClipboardFunc = _this.gridOptionsWrapper.getProcessCellFromClipboardFunc();\n\n          firstRowValue = _this.userProcessCell(rowNode, column, firstRowValue, processCellFromClipboardFunc, ag_grid_community_1.Constants.EXPORT_TYPE_DRAG_COPY);\n\n          _this.valueService.setValue(rowNode, column, firstRowValue);\n\n          var gridCellDef = {\n            rowIndex: currentRow.rowIndex,\n            floating: currentRow.floating,\n            column: column\n          };\n          var cellId = new ag_grid_community_1.GridCell(gridCellDef).createId();\n          cellsToFlash[cellId] = true;\n        });\n      }\n    };\n\n    this.iterateActiveRanges(true, rowCallback); // this is very heavy, should possibly just refresh the specific cells?\n\n    this.rowRenderer.refreshCells({\n      rowNodes: updatedRowNodes,\n      columns: updatedColumnIds\n    });\n    this.dispatchFlashCells(cellsToFlash);\n    this.fireRowChanged(updatedRowNodes);\n    this.eventService.dispatchEvent({\n      type: ag_grid_community_1.Events.EVENT_PASTE_END,\n      api: this.gridOptionsWrapper.getApi(),\n      columnApi: this.gridOptionsWrapper.getColumnApi(),\n      source: 'rangeDown'\n    });\n  };\n\n  ClipboardService.prototype.fireRowChanged = function (rowNodes) {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.isFullRowEdit()) {\n      return;\n    }\n\n    rowNodes.forEach(function (rowNode) {\n      var event = {\n        type: ag_grid_community_1.Events.EVENT_ROW_VALUE_CHANGED,\n        node: rowNode,\n        data: rowNode.data,\n        rowIndex: rowNode.rowIndex,\n        rowPinned: rowNode.rowPinned,\n        context: _this.gridOptionsWrapper.getContext(),\n        api: _this.gridOptionsWrapper.getApi(),\n        columnApi: _this.gridOptionsWrapper.getColumnApi()\n      };\n\n      _this.eventService.dispatchEvent(event);\n    });\n  };\n\n  ClipboardService.prototype.multipleCellRange = function (clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, updatedColumnIds, type) {\n    var _this = this;\n\n    clipboardGridData.forEach(function (clipboardRowData) {\n      // if we have come to end of rows in grid, then skip\n      if (!currentRow) {\n        return;\n      }\n\n      var rowNode = _this.getRowNode(currentRow);\n\n      if (rowNode) {\n        updatedRowNodes.push(rowNode);\n        clipboardRowData.forEach(function (value, index) {\n          var column = columnsToPasteInto[index];\n\n          if (ag_grid_community_1._.missing(column)) {\n            return;\n          }\n\n          if (rowNode && !column.isCellEditable(rowNode)) {\n            return;\n          }\n\n          _this.updateCellValue(rowNode, column, value, currentRow, cellsToFlash, updatedColumnIds, type);\n        }); // move to next row down for next set of values\n\n        currentRow = _this.cellNavigationService.getRowBelow(currentRow);\n      }\n    });\n    return currentRow;\n  };\n\n  ClipboardService.prototype.singleCellRange = function (parsedData, updatedRowNodes, currentRow, cellsToFlash, updatedColumnIds) {\n    var _this = this;\n\n    var value = parsedData[0][0];\n\n    var rowCallback = function rowCallback(currentRow, rowNode, columns, index, isLastRow) {\n      updatedRowNodes.push(rowNode);\n      columns.forEach(function (column) {\n        if (column.isCellEditable(rowNode)) {\n          _this.updateCellValue(rowNode, column, value, currentRow, cellsToFlash, updatedColumnIds, ag_grid_community_1.Constants.EXPORT_TYPE_CLIPBOARD);\n        }\n      });\n    };\n\n    this.iterateActiveRanges(false, rowCallback);\n  };\n\n  ClipboardService.prototype.updateCellValue = function (rowNode, column, value, currentRow, cellsToFlash, updatedColumnIds, type) {\n    if (!rowNode || !currentRow) {\n      return;\n    }\n\n    if (column.isSuppressPaste(rowNode)) {\n      return;\n    }\n\n    var processedValue = this.userProcessCell(rowNode, column, value, this.gridOptionsWrapper.getProcessCellFromClipboardFunc(), type);\n    this.valueService.setValue(rowNode, column, processedValue);\n    var gridCellDef = {\n      rowIndex: currentRow.rowIndex,\n      floating: currentRow.floating,\n      column: column\n    };\n    var cellId = new ag_grid_community_1.GridCell(gridCellDef).createId();\n    cellsToFlash[cellId] = true;\n\n    if (updatedColumnIds.indexOf(column.getId()) < 0) {\n      updatedColumnIds.push(column.getId());\n    }\n  };\n\n  ClipboardService.prototype.copyToClipboard = function (includeHeaders) {\n    this.logger.log(\"copyToClipboard: includeHeaders = \" + includeHeaders); // don't override 'includeHeaders' if it has been explicitly set to 'false'\n\n    if (typeof includeHeaders === 'undefined') {\n      includeHeaders = this.gridOptionsWrapper.isCopyHeadersToClipboard();\n    }\n\n    var selectedRowsToCopy = !this.selectionController.isEmpty() && !this.gridOptionsWrapper.isSuppressCopyRowsToClipboard(); // default is copy range if exists, otherwise rows\n\n    if (this.rangeController.isMoreThanOneCell()) {\n      this.copySelectedRangeToClipboard(includeHeaders);\n    } else if (selectedRowsToCopy) {\n      // otherwise copy selected rows if they exist\n      this.copySelectedRowsToClipboard(includeHeaders);\n    } else if (this.focusedCellController.isAnyCellFocused()) {\n      // if there is a focused cell, copy this\n      this.copyFocusedCellToClipboard(includeHeaders);\n    } else {\n      // lastly if no focused cell, try range again. this can happen\n      // if use has cellSelection turned off (so no focused cell)\n      // but has a cell clicked, so there exists a cell range\n      // of exactly one cell (hence the first 'if' above didn't\n      // get executed).\n      this.copySelectedRangeToClipboard(includeHeaders);\n    }\n  };\n\n  ClipboardService.prototype.iterateActiveRanges = function (onlyFirst, rowCallback, columnCallback) {\n    var _this = this;\n\n    if (this.rangeController.isEmpty()) {\n      return;\n    }\n\n    var rangeSelections = this.rangeController.getCellRanges();\n\n    if (onlyFirst) {\n      var range = rangeSelections[0];\n      this.iterateActiveRange(range, rowCallback, columnCallback, true);\n    } else {\n      rangeSelections.forEach(function (range, idx) {\n        return _this.iterateActiveRange(range, rowCallback, columnCallback, idx === rangeSelections.length - 1);\n      });\n    }\n  };\n\n  ClipboardService.prototype.iterateActiveRange = function (range, rowCallback, columnCallback, isLastRange) {\n    // get starting and ending row, remember rowEnd could be before rowStart\n    var startRow = range.start.getGridRow();\n    var endRow = range.end.getGridRow();\n    var startRowIsFirst = startRow.before(endRow);\n    var currentRow = startRowIsFirst ? startRow : endRow;\n    var lastRow = startRowIsFirst ? endRow : startRow;\n\n    if (columnCallback && ag_grid_community_1._.exists(columnCallback) && range.columns) {\n      columnCallback(range.columns);\n    }\n\n    var rangeIndex = 0;\n    var isLastRow = false; // the currentRow could be missing if the user sets the active range manually, and sets a range\n    // that is outside of the grid (eg. sets range rows 0 to 100, but grid has only 20 rows).\n\n    while (!isLastRow && !ag_grid_community_1._.missing(currentRow) && currentRow) {\n      var rowNode = this.getRowNode(currentRow);\n      isLastRow = currentRow.equals(lastRow);\n      rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);\n      currentRow = this.cellNavigationService.getRowBelow(currentRow);\n    }\n  };\n\n  ClipboardService.prototype.copySelectedRangeToClipboard = function (includeHeaders) {\n    var _this = this;\n\n    if (includeHeaders === void 0) {\n      includeHeaders = false;\n    }\n\n    if (this.rangeController.isEmpty()) {\n      return;\n    }\n\n    var deliminator = this.gridOptionsWrapper.getClipboardDeliminator();\n    var data = '';\n    var cellsToFlash = {}; // adds columns to the data\n\n    var columnCallback = function columnCallback(columns) {\n      if (!includeHeaders) {\n        return;\n      }\n\n      columns.forEach(function (column, index) {\n        var value = _this.columnController.getDisplayNameForColumn(column, 'clipboard', true);\n\n        var processedValue = _this.userProcessHeader(column, value, _this.gridOptionsWrapper.getProcessHeaderForClipboardFunc());\n\n        if (index != 0) {\n          data += deliminator;\n        }\n\n        if (ag_grid_community_1._.exists(processedValue)) {\n          data += processedValue;\n        }\n      });\n      data += '\\r\\n';\n    }; // adds cell values to the data\n\n\n    var rowCallback = function rowCallback(currentRow, rowNode, columns, index, isLastRow) {\n      columns.forEach(function (column, index) {\n        var value = _this.valueService.getValue(column, rowNode);\n\n        var processedValue = _this.userProcessCell(rowNode, column, value, _this.gridOptionsWrapper.getProcessCellForClipboardFunc(), ag_grid_community_1.Constants.EXPORT_TYPE_CLIPBOARD);\n\n        if (index != 0) {\n          data += deliminator;\n        }\n\n        if (ag_grid_community_1._.exists(processedValue)) {\n          data += processedValue;\n        }\n\n        var gridCellDef = {\n          rowIndex: currentRow.rowIndex,\n          floating: currentRow.floating,\n          column: column\n        };\n        var cellId = new ag_grid_community_1.GridCell(gridCellDef).createId();\n        cellsToFlash[cellId] = true;\n      });\n\n      if (!isLastRow) {\n        data += '\\r\\n';\n      }\n    };\n\n    this.iterateActiveRanges(false, rowCallback, columnCallback);\n    this.copyDataToClipboard(data);\n    this.dispatchFlashCells(cellsToFlash);\n  };\n\n  ClipboardService.prototype.copyFocusedCellToClipboard = function (includeHeaders) {\n    if (includeHeaders === void 0) {\n      includeHeaders = false;\n    }\n\n    var focusedCell = this.focusedCellController.getFocusedCell();\n\n    if (ag_grid_community_1._.missing(focusedCell)) {\n      return;\n    }\n\n    var currentRow = focusedCell.getGridRow();\n    var rowNode = this.getRowNode(currentRow);\n    var column = focusedCell.column;\n    var value = this.valueService.getValue(column, rowNode);\n    var processedValue = this.userProcessCell(rowNode, column, value, this.gridOptionsWrapper.getProcessCellForClipboardFunc(), ag_grid_community_1.Constants.EXPORT_TYPE_CLIPBOARD);\n\n    if (ag_grid_community_1._.missing(processedValue)) {\n      // copy the new line character to clipboard instead of an empty string, as the 'execCommand' will ignore it.\n      // this behaviour is consistent with how Excel works!\n      processedValue = '\\n';\n    }\n\n    var data = '';\n\n    if (includeHeaders) {\n      data = this.columnController.getDisplayNameForColumn(column, 'clipboard', true) + '\\r\\n';\n    }\n\n    data += processedValue.toString();\n    this.copyDataToClipboard(data);\n    var cellId = focusedCell.createId();\n    var cellsToFlash = {};\n    cellsToFlash[cellId] = true;\n    this.dispatchFlashCells(cellsToFlash);\n  };\n\n  ClipboardService.prototype.dispatchFlashCells = function (cellsToFlash) {\n    var _this = this;\n\n    window.setTimeout(function () {\n      var event = {\n        type: ag_grid_community_1.Events.EVENT_FLASH_CELLS,\n        cells: cellsToFlash,\n        api: _this.gridApi,\n        columnApi: _this.columnApi\n      };\n\n      _this.eventService.dispatchEvent(event);\n    }, 0);\n  };\n\n  ClipboardService.prototype.userProcessCell = function (rowNode, column, value, func, type) {\n    if (func) {\n      var params = {\n        column: column,\n        node: rowNode,\n        value: value,\n        api: this.gridOptionsWrapper.getApi(),\n        columnApi: this.gridOptionsWrapper.getColumnApi(),\n        context: this.gridOptionsWrapper.getContext(),\n        type: type\n      };\n      return func(params);\n    } else {\n      return value;\n    }\n  };\n\n  ClipboardService.prototype.userProcessHeader = function (column, value, func) {\n    if (func) {\n      var params = {\n        column: column,\n        api: this.gridOptionsWrapper.getApi(),\n        columnApi: this.gridOptionsWrapper.getColumnApi(),\n        context: this.gridOptionsWrapper.getContext()\n      };\n      return func(params);\n    } else {\n      return value;\n    }\n  };\n\n  ClipboardService.prototype.getRowNode = function (gridRow) {\n    switch (gridRow.floating) {\n      case ag_grid_community_1.Constants.PINNED_TOP:\n        return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n\n      case ag_grid_community_1.Constants.PINNED_BOTTOM:\n        return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n\n      default:\n        return this.rowModel.getRow(gridRow.rowIndex);\n    }\n  };\n\n  ClipboardService.prototype.copySelectedRowsToClipboard = function (includeHeaders, columnKeys) {\n    if (includeHeaders === void 0) {\n      includeHeaders = false;\n    }\n\n    var skipHeader = !includeHeaders;\n    var deliminator = this.gridOptionsWrapper.getClipboardDeliminator();\n    var params = {\n      columnKeys: columnKeys,\n      skipHeader: skipHeader,\n      skipFooters: true,\n      suppressQuotes: true,\n      columnSeparator: deliminator,\n      onlySelected: true,\n      processCellCallback: this.gridOptionsWrapper.getProcessCellForClipboardFunc(),\n      processHeaderCallback: this.gridOptionsWrapper.getProcessHeaderForClipboardFunc()\n    };\n    var data = this.csvCreator.getDataAsCsv(params);\n    this.copyDataToClipboard(data);\n  };\n\n  ClipboardService.prototype.copyDataToClipboard = function (data) {\n    var userProvidedFunc = this.gridOptionsWrapper.getSendToClipboardFunc();\n\n    if (userProvidedFunc && ag_grid_community_1._.exists(userProvidedFunc)) {\n      var params = {\n        data: data\n      };\n      userProvidedFunc(params);\n    } else {\n      this.executeOnTempElement(function (element) {\n        element.value = data;\n        element.select();\n        element.focus();\n        var result = document.execCommand('copy');\n\n        if (!result) {\n          console.warn('ag-grid: Browser did not allow document.execCommand(\\'copy\\'). Ensure ' + 'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise ' + 'the browser will prevent it for security reasons.');\n        }\n      });\n    }\n  };\n\n  ClipboardService.prototype.executeOnTempElement = function (callbackNow, callbackAfter) {\n    var eTempInput = document.createElement('textarea');\n    eTempInput.style.width = '1px';\n    eTempInput.style.height = '1px';\n    eTempInput.style.top = '0px';\n    eTempInput.style.left = '0px';\n    eTempInput.style.position = 'absolute';\n    eTempInput.style.opacity = '0.0';\n    var guiRoot = this.gridCore.getRootGui();\n    guiRoot.appendChild(eTempInput);\n\n    try {\n      callbackNow(eTempInput);\n    } catch (err) {\n      console.warn('ag-grid: Browser does not support document.execCommand(\\'copy\\') for clipboard operations');\n    } //It needs 100 otherwise OS X seemed to not always be able to paste... Go figure...\n\n\n    if (callbackAfter) {\n      window.setTimeout(function () {\n        callbackAfter(eTempInput);\n        guiRoot.removeChild(eTempInput);\n      }, 100);\n    } else {\n      guiRoot.removeChild(eTempInput);\n    }\n  }; // From http://stackoverflow.com/questions/1293147/javascript-code-to-parse-csv-data\n  // This will parse a delimited string into an array of arrays.\n  // Note: this code fixes an issue with the example posted on stack overflow where it doesn't correctly handle\n  // empty values in the first cell.\n\n\n  ClipboardService.prototype.dataToArray = function (strData) {\n    var delimiter = this.gridOptionsWrapper.getClipboardDeliminator(); // Create a regular expression to parse the CSV values.\n\n    var objPattern = new RegExp( // Delimiters.\n    '(\\\\' + delimiter + '|\\\\r?\\\\n|\\\\r|^)' + // Quoted fields.\n    '(?:\"([^\\\"]*(?:\"\"[^\\\"]*)*)\"|' + // Standard fields.\n    '([^\\\\' + delimiter + '\\\\r\\\\n]*))', \"gi\"); // Create an array to hold our data. Give the array\n    // a default empty first row.\n\n    var arrData = [[]]; // Create an array to hold our individual pattern matching groups.\n\n    var arrMatches; // Required for handling edge case on first row copy\n\n    var atFirstRow = true; // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n\n    while (arrMatches = objPattern.exec(strData)) {\n      // Get the delimiter that was found.\n      var strMatchedDelimiter = arrMatches[1]; // Handles case when first row is an empty cell, insert an empty string before delimiter\n\n      if (atFirstRow && strMatchedDelimiter || !arrMatches.index && arrMatches[0].charAt(0) === delimiter) {\n        arrData[0].push('');\n      } // Check to see if the given delimiter has a length\n      // (is not the start of string) and if it matches\n      // field delimiter. If id does not, then we know\n      // that this delimiter is a row delimiter.\n\n\n      if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push([]);\n      }\n\n      var strMatchedValue = void 0; // Now that we have our delimiter out of the way,\n      // let's check to see which kind of value we\n      // captured (quoted or unquoted).\n\n      if (arrMatches[2]) {\n        // We found a quoted value. When we capture\n        // this value, unescaped any double quotes.\n        strMatchedValue = arrMatches[2].replace(new RegExp('\"\"', 'g'), '\"');\n      } else {\n        // We found a non-quoted value.\n        strMatchedValue = arrMatches[3];\n      } // Now that we have our value string, let's add\n      // it to the data array.\n\n\n      arrData[arrData.length - 1].push(strMatchedValue);\n      atFirstRow = false;\n    } // Return the parsed data.\n\n\n    return arrData;\n  };\n\n  ClipboardService.prototype.rangeSize = function () {\n    var ranges = this.rangeController.getCellRanges();\n\n    var _a = ranges ? [ranges[0].start.rowIndex, ranges[0].end.rowIndex] : [0, 0],\n        startRange = _a[0],\n        endRange = _a[1];\n\n    return (startRange > endRange ? startRange - endRange : endRange - startRange) + 1;\n  };\n\n  __decorate([ag_grid_community_1.Autowired('csvCreator'), __metadata(\"design:type\", ag_grid_community_1.CsvCreator)], ClipboardService.prototype, \"csvCreator\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('loggerFactory'), __metadata(\"design:type\", ag_grid_community_1.LoggerFactory)], ClipboardService.prototype, \"loggerFactory\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('selectionController'), __metadata(\"design:type\", ag_grid_community_1.SelectionController)], ClipboardService.prototype, \"selectionController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rangeController'), __metadata(\"design:type\", rangeController_1.RangeController)], ClipboardService.prototype, \"rangeController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rowModel'), __metadata(\"design:type\", Object)], ClipboardService.prototype, \"rowModel\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('pinnedRowModel'), __metadata(\"design:type\", ag_grid_community_1.PinnedRowModel)], ClipboardService.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('valueService'), __metadata(\"design:type\", ag_grid_community_1.ValueService)], ClipboardService.prototype, \"valueService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('focusedCellController'), __metadata(\"design:type\", ag_grid_community_1.FocusedCellController)], ClipboardService.prototype, \"focusedCellController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rowRenderer'), __metadata(\"design:type\", ag_grid_community_1.RowRenderer)], ClipboardService.prototype, \"rowRenderer\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnController'), __metadata(\"design:type\", ag_grid_community_1.ColumnController)], ClipboardService.prototype, \"columnController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('eventService'), __metadata(\"design:type\", ag_grid_community_1.EventService)], ClipboardService.prototype, \"eventService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('cellNavigationService'), __metadata(\"design:type\", ag_grid_community_1.CellNavigationService)], ClipboardService.prototype, \"cellNavigationService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)], ClipboardService.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnApi'), __metadata(\"design:type\", ag_grid_community_1.ColumnApi)], ClipboardService.prototype, \"columnApi\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridApi'), __metadata(\"design:type\", ag_grid_community_1.GridApi)], ClipboardService.prototype, \"gridApi\", void 0);\n\n  __decorate([ag_grid_community_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], ClipboardService.prototype, \"init\", null);\n\n  ClipboardService = __decorate([ag_grid_community_1.Bean('clipboardService')], ClipboardService);\n  return ClipboardService;\n}();\n\nexports.ClipboardService = ClipboardService;","map":null,"metadata":{},"sourceType":"script"}