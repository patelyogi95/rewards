{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar serverSideBlock_1 = require(\"./serverSideBlock\");\n\nvar ServerSideCache =\n/** @class */\nfunction (_super) {\n  __extends(ServerSideCache, _super);\n\n  function ServerSideCache(cacheParams, parentRowNode) {\n    var _this = _super.call(this, cacheParams) || this; // this will always be zero for the top level cache only,\n    // all the other ones change as the groups open and close\n\n\n    _this.displayIndexStart = 0;\n    _this.displayIndexEnd = 0; // not sure if setting this one to zero is necessary\n\n    _this.cacheTop = 0;\n    _this.blockHeights = {};\n    _this.parentRowNode = parentRowNode;\n    return _this;\n  }\n\n  ServerSideCache.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ServerSideCache');\n  };\n\n  ServerSideCache.prototype.init = function () {\n    _super.prototype.init.call(this);\n  };\n\n  ServerSideCache.prototype.getRowBounds = function (index) {\n    var _this = this;\n\n    this.logger.log(\"getRowBounds(\" + index + \")\"); // we return null if row not found\n    // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be RowBounds\n\n    var result;\n    var blockFound = false; // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be ServerSideBlock\n\n    var lastBlock = null;\n    this.forEachBlockInOrder(function (block) {\n      if (blockFound) {\n        return;\n      }\n\n      if (block.isDisplayIndexInBlock(index)) {\n        result = block.getRowBounds(index, _this.getVirtualRowCount());\n        blockFound = true;\n      } else if (block.isBlockBefore(index)) {\n        lastBlock = block;\n      }\n    });\n\n    if (!blockFound) {\n      var nextRowTop = void 0;\n      var nextRowIndex = void 0;\n\n      if (lastBlock !== null) {\n        nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n        nextRowIndex = lastBlock.getDisplayIndexEnd();\n      } else {\n        nextRowTop = this.cacheTop;\n        nextRowIndex = this.displayIndexStart;\n      }\n\n      var rowsBetween = index - nextRowIndex;\n      result = {\n        rowHeight: this.cacheParams.rowHeight,\n        rowTop: nextRowTop + rowsBetween * this.cacheParams.rowHeight\n      };\n    } // NOTE: what about purged blocks\n\n\n    this.logger.log(\"getRowBounds(\" + index + \"), result = \" + result);\n    return result;\n  };\n\n  ServerSideCache.prototype.destroyBlock = function (block) {\n    _super.prototype.destroyBlock.call(this, block);\n  };\n\n  ServerSideCache.prototype.getRowIndexAtPixel = function (pixel) {\n    var _this = this;\n\n    this.logger.log(\"getRowIndexAtPixel(\" + pixel + \")\"); // we return null if row not found\n    // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be number\n\n    var result;\n    var blockFound = false; // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be ServerSideBlock\n\n    var lastBlock;\n    this.forEachBlockInOrder(function (block) {\n      if (blockFound) {\n        return;\n      }\n\n      if (block.isPixelInRange(pixel)) {\n        result = block.getRowIndexAtPixel(pixel, _this.getVirtualRowCount());\n        blockFound = true;\n      } else if (block.getBlockTop() < pixel) {\n        lastBlock = block;\n      }\n    });\n\n    if (!blockFound) {\n      var nextRowTop = void 0;\n      var nextRowIndex = void 0;\n\n      if (lastBlock) {\n        nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n        nextRowIndex = lastBlock.getDisplayIndexEnd();\n      } else {\n        nextRowTop = this.cacheTop;\n        nextRowIndex = this.displayIndexStart;\n      }\n\n      var pixelsBetween = pixel - nextRowTop;\n      var rowsBetween = pixelsBetween / this.cacheParams.rowHeight | 0;\n      result = nextRowIndex + rowsBetween;\n    }\n\n    var lastAllowedIndex = this.getDisplayIndexEnd() - 1;\n\n    if (result > lastAllowedIndex) {\n      result = lastAllowedIndex;\n    } //NOTE: purged\n\n\n    this.logger.log(\"getRowIndexAtPixel(\" + pixel + \") result = \" + result);\n    return result;\n  };\n\n  ServerSideCache.prototype.clearRowTops = function () {\n    var _this = this;\n\n    this.forEachBlockInOrder(function (block) {\n      return block.clearRowTops(_this.getVirtualRowCount());\n    });\n  };\n\n  ServerSideCache.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n    var _this = this;\n\n    this.displayIndexStart = displayIndexSeq.peek();\n    this.cacheTop = nextRowTop.value;\n    var lastBlockId = -1;\n    var blockSize = this.cacheParams.blockSize ? this.cacheParams.blockSize : serverSideBlock_1.ServerSideBlock.DefaultBlockSize;\n    this.forEachBlockInOrder(function (currentBlock, blockId) {\n      // if we skipped blocks, then we need to skip the row indexes. we assume that all missing\n      // blocks are made up of closed RowNodes only (if they were groups), as we never expire from\n      // the cache if any row nodes are open.\n      var blocksSkippedCount = blockId - lastBlockId - 1;\n      var rowsSkippedCount = blocksSkippedCount * blockSize;\n\n      if (rowsSkippedCount > 0) {\n        displayIndexSeq.skip(rowsSkippedCount);\n      }\n\n      for (var i = 1; i <= blocksSkippedCount; i++) {\n        var blockToAddId = blockId - i;\n\n        if (ag_grid_community_1._.exists(_this.blockHeights[blockToAddId])) {\n          nextRowTop.value += _this.blockHeights[blockToAddId];\n        } else {\n          nextRowTop.value += blockSize * _this.cacheParams.rowHeight;\n        }\n      }\n\n      lastBlockId = blockId;\n      currentBlock.setDisplayIndexes(displayIndexSeq, _this.getVirtualRowCount(), nextRowTop);\n      _this.blockHeights[blockId] = currentBlock.getBlockHeight();\n    }); // if any blocks missing at the end, need to increase the row index for them also\n    // eg if block size = 10, we have total rows of 25 (indexes 0 .. 24), but first 2 blocks loaded (because\n    // last row was ejected from cache), then:\n    // lastVisitedRow = 19, virtualRowCount = 25, rows not accounted for = 5 (24 - 19)\n\n    var lastVisitedRow = (lastBlockId + 1) * blockSize - 1;\n    var rowCount = this.getVirtualRowCount();\n    var rowsNotAccountedFor = rowCount - lastVisitedRow - 1;\n\n    if (rowsNotAccountedFor > 0) {\n      displayIndexSeq.skip(rowsNotAccountedFor);\n      nextRowTop.value += rowsNotAccountedFor * this.cacheParams.rowHeight;\n    }\n\n    this.displayIndexEnd = displayIndexSeq.peek();\n    this.cacheHeight = nextRowTop.value - this.cacheTop;\n  }; // gets called in a) init() above and b) by the grid\n\n\n  ServerSideCache.prototype.getRow = function (displayRowIndex, dontCreateBlock) {\n    if (dontCreateBlock === void 0) {\n      dontCreateBlock = false;\n    } // this can happen if asking for a row that doesn't exist in the model,\n    // eg if a cell range is selected, and the user filters so rows no longer\n    // exist\n\n\n    if (!this.isDisplayIndexInCache(displayRowIndex)) {\n      return null;\n    } // if we have the block, then this is the block\n\n\n    var block = null; // this is the last block that we have BEFORE the right block\n    // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be ServerSideBlock\n\n    var beforeBlock = null;\n    this.forEachBlockInOrder(function (currentBlock) {\n      if (currentBlock.isDisplayIndexInBlock(displayRowIndex)) {\n        block = currentBlock;\n      } else if (currentBlock.isBlockBefore(displayRowIndex)) {\n        // this will get assigned many times, but the last time will\n        // be the closest block to the required block that is BEFORE\n        beforeBlock = currentBlock;\n      }\n    }); // when we are moving rows around, we don't want to trigger loads\n\n    if (ag_grid_community_1._.missing(block) && dontCreateBlock) {\n      return null;\n    }\n\n    var blockSize = this.cacheParams.blockSize ? this.cacheParams.blockSize : serverSideBlock_1.ServerSideBlock.DefaultBlockSize; // if block not found, we need to load it\n\n    if (ag_grid_community_1._.missing(block)) {\n      var blockNumber = void 0;\n      var displayIndexStart_1;\n      var nextRowTop = void 0; // because missing blocks are always fully closed, we can work out\n      // the start index of the block we want by hopping from the closest block,\n      // as we know the row count in closed blocks is equal to the page size\n\n      if (beforeBlock) {\n        blockNumber = beforeBlock.getBlockNumber() + 1;\n        displayIndexStart_1 = beforeBlock.getDisplayIndexEnd();\n        nextRowTop = beforeBlock.getBlockHeight() + beforeBlock.getBlockTop();\n\n        var isInRange = function isInRange() {\n          return displayRowIndex >= displayIndexStart_1 && displayRowIndex < displayIndexStart_1 + blockSize;\n        };\n\n        while (!isInRange()) {\n          displayIndexStart_1 += blockSize;\n          var cachedBlockHeight = this.blockHeights[blockNumber];\n\n          if (ag_grid_community_1._.exists(cachedBlockHeight)) {\n            nextRowTop += cachedBlockHeight;\n          } else {\n            nextRowTop += this.cacheParams.rowHeight * blockSize;\n          }\n\n          blockNumber++;\n        }\n      } else {\n        var localIndex = displayRowIndex - this.displayIndexStart;\n        blockNumber = Math.floor(localIndex / blockSize);\n        displayIndexStart_1 = this.displayIndexStart + blockNumber * blockSize;\n        nextRowTop = this.cacheTop + blockNumber * blockSize * this.cacheParams.rowHeight;\n      }\n\n      block = this.createBlock(blockNumber, displayIndexStart_1, {\n        value: nextRowTop\n      });\n      this.logger.log(\"block missing, rowIndex = \" + displayRowIndex + \", creating #\" + blockNumber + \", displayIndexStart = \" + displayIndexStart_1);\n    }\n\n    var rowNode = block ? block.getRow(displayRowIndex) : null;\n    return rowNode;\n  };\n\n  ServerSideCache.prototype.createBlock = function (blockNumber, displayIndex, nextRowTop) {\n    var newBlock = new serverSideBlock_1.ServerSideBlock(blockNumber, this.parentRowNode, this.cacheParams, this);\n    this.getContext().wireBean(newBlock);\n    var displayIndexSequence = new ag_grid_community_1.NumberSequence(displayIndex);\n    newBlock.setDisplayIndexes(displayIndexSequence, this.getVirtualRowCount(), nextRowTop);\n    this.postCreateBlock(newBlock);\n    return newBlock;\n  };\n\n  ServerSideCache.prototype.getDisplayIndexEnd = function () {\n    return this.displayIndexEnd;\n  };\n\n  ServerSideCache.prototype.isDisplayIndexInCache = function (displayIndex) {\n    if (this.getVirtualRowCount() === 0) {\n      return false;\n    }\n\n    return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n  };\n\n  ServerSideCache.prototype.getChildCache = function (keys) {\n    var _this = this;\n\n    if (ag_grid_community_1._.missingOrEmpty(keys)) {\n      return this;\n    }\n\n    var nextKey = keys[0];\n    var nextServerSideCache = null;\n    this.forEachBlockInOrder(function (block) {\n      // callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number\n      block.forEachNodeShallow(function (rowNode) {\n        if (rowNode.key === nextKey) {\n          nextServerSideCache = rowNode.childrenCache;\n        }\n      }, new ag_grid_community_1.NumberSequence(), _this.getVirtualRowCount());\n    });\n\n    if (nextServerSideCache) {\n      var keyListForNextLevel = keys.slice(1, keys.length);\n      return nextServerSideCache ? nextServerSideCache.getChildCache(keyListForNextLevel) : null;\n    } else {\n      return null;\n    }\n  };\n\n  ServerSideCache.prototype.isPixelInRange = function (pixel) {\n    if (this.getVirtualRowCount() === 0) {\n      return false;\n    }\n\n    return pixel >= this.cacheTop && pixel < this.cacheTop + this.cacheHeight;\n  };\n\n  ServerSideCache.prototype.refreshCacheAfterSort = function (changedColumnsInSort, rowGroupColIds) {\n    var _this = this;\n\n    var level = this.parentRowNode.level + 1;\n    var grouping = level < this.cacheParams.rowGroupCols.length;\n    var shouldPurgeCache;\n\n    if (grouping) {\n      var groupColVo = this.cacheParams.rowGroupCols[level];\n      var groupField = groupColVo.field;\n      var rowGroupBlock = rowGroupColIds.indexOf(groupField) > -1;\n      var sortingByGroup = changedColumnsInSort.indexOf(groupField) > -1;\n      shouldPurgeCache = rowGroupBlock && sortingByGroup;\n    } else {\n      shouldPurgeCache = true;\n    }\n\n    if (shouldPurgeCache) {\n      this.purgeCache();\n    } else {\n      this.forEachBlockInOrder(function (block) {\n        if (block.isGroupLevel()) {\n          var callback = function callback(rowNode) {\n            var nextCache = rowNode.childrenCache;\n\n            if (nextCache) {\n              nextCache.refreshCacheAfterSort(changedColumnsInSort, rowGroupColIds);\n            }\n          };\n\n          block.forEachNodeShallow(callback, new ag_grid_community_1.NumberSequence(), _this.getVirtualRowCount());\n        }\n      });\n    }\n  };\n\n  __decorate([ag_grid_community_1.Autowired('eventService'), __metadata(\"design:type\", ag_grid_community_1.EventService)], ServerSideCache.prototype, \"eventService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)], ServerSideCache.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([__param(0, ag_grid_community_1.Qualifier('loggerFactory')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [ag_grid_community_1.LoggerFactory]), __metadata(\"design:returntype\", void 0)], ServerSideCache.prototype, \"setBeans\", null);\n\n  __decorate([ag_grid_community_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], ServerSideCache.prototype, \"init\", null);\n\n  return ServerSideCache;\n}(ag_grid_community_1.RowNodeCache);\n\nexports.ServerSideCache = ServerSideCache;","map":null,"metadata":{},"sourceType":"script"}