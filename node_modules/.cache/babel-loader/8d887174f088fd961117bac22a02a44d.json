{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar PivotColDefService =\n/** @class */\nfunction () {\n  function PivotColDefService() {}\n\n  PivotColDefService.prototype.createPivotColumnDefs = function (uniqueValues) {\n    // this is passed to the columnController, to configure the columns and groups we show\n    var pivotColumnGroupDefs = []; // this is used by the aggregation stage, to do the aggregation based on the pivot columns\n\n    var pivotColumnDefs = [];\n    var pivotColumns = this.columnController.getPivotColumns();\n    var valueColumns = this.columnController.getValueColumns();\n    var levelsDeep = pivotColumns.length;\n    var columnIdSequence = new ag_grid_community_1.NumberSequence();\n    this.recursivelyAddGroup(pivotColumnGroupDefs, pivotColumnDefs, 1, uniqueValues, [], columnIdSequence, levelsDeep, pivotColumns);\n    this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs, valueColumns, pivotColumns, columnIdSequence);\n    this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence); // we clone, so the colDefs in pivotColumnsGroupDefs and pivotColumnDefs are not shared. this is so that\n    // any changes the user makes (via processSecondaryColumnDefinitions) don't impact the internal aggregations,\n    // as these use the col defs also\n\n    var pivotColumnDefsClone = pivotColumnDefs.map(function (colDef) {\n      return ag_grid_community_1._.cloneObject(colDef);\n    });\n    return {\n      pivotColumnGroupDefs: pivotColumnGroupDefs,\n      pivotColumnDefs: pivotColumnDefsClone\n    };\n  }; // parentChildren - the list of colDefs we are adding to\n  // @index - how far the column is from the top (also same as pivotKeys.length)\n  // @uniqueValues - the values for which we should create a col for\n  // @pivotKeys - the keys for the pivot, eg if pivoting on {Language,Country} then could be {English,Ireland}\n\n\n  PivotColDefService.prototype.recursivelyAddGroup = function (parentChildren, pivotColumnDefs, index, uniqueValues, pivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns) {\n    var _this = this;\n\n    ag_grid_community_1._.iterateObject(uniqueValues, function (key, value) {\n      var newPivotKeys = pivotKeys.slice(0);\n      newPivotKeys.push(key);\n      var createGroup = index !== levelsDeep;\n\n      if (createGroup) {\n        var groupDef = {\n          children: [],\n          headerName: key,\n          pivotKeys: newPivotKeys,\n          columnGroupShow: 'open',\n          groupId: 'pivot' + columnIdSequence.next()\n        };\n        parentChildren.push(groupDef);\n\n        _this.recursivelyAddGroup(groupDef.children, pivotColumnDefs, index + 1, value, newPivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns);\n      } else {\n        var measureColumns = _this.columnController.getValueColumns();\n\n        var valueGroup_1 = {\n          children: [],\n          headerName: key,\n          pivotKeys: newPivotKeys,\n          columnGroupShow: 'open',\n          groupId: 'pivot' + columnIdSequence.next()\n        }; // if no value columns selected, then we insert one blank column, so the user at least sees columns\n        // rendered. otherwise the grid would render with no columns (just empty groups) which would give the\n        // impression that the grid is broken\n\n        if (measureColumns.length === 0) {\n          // this is the blank column, for when no value columns enabled.\n          var colDef_1 = _this.createColDef(null, '-', newPivotKeys, columnIdSequence);\n\n          valueGroup_1.children.push(colDef_1);\n          pivotColumnDefs.push(colDef_1);\n        } else {\n          measureColumns.forEach(function (measureColumn) {\n            var columnName = _this.columnController.getDisplayNameForColumn(measureColumn, 'header');\n\n            var colDef = _this.createColDef(measureColumn, columnName, newPivotKeys, columnIdSequence);\n\n            colDef.columnGroupShow = 'open';\n            valueGroup_1.children.push(colDef);\n            pivotColumnDefs.push(colDef);\n          });\n        }\n\n        parentChildren.push(valueGroup_1);\n      }\n    }); // sort by either user provided comparator, or our own one\n\n\n    var colDef = primaryPivotColumns[index - 1].getColDef();\n    var userComparator = colDef.pivotComparator;\n    var comparator = this.headerNameComparator.bind(this, userComparator);\n    parentChildren.sort(comparator);\n  };\n\n  PivotColDefService.prototype.addPivotTotalsToGroups = function (pivotColumnGroupDefs, pivotColumnDefs, columnIdSequence) {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.getPivotColumnGroupTotals()) {\n      return;\n    }\n\n    var insertAfter = this.gridOptionsWrapper.getPivotColumnGroupTotals() === 'after';\n    var valueCols = this.columnController.getValueColumns();\n    var aggFuncs = valueCols.map(function (valueCol) {\n      return valueCol.getAggFunc();\n    }); // don't add pivot totals if there is less than 1 aggFunc or they are not all the same\n\n    if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {\n      // console.warn('ag-Grid: aborting adding pivot total columns - value columns require same aggFunc');\n      return;\n    } // arbitrarily select a value column to use as a template for pivot columns\n\n\n    var valueColumn = valueCols[0];\n    pivotColumnGroupDefs.forEach(function (groupDef) {\n      _this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter);\n    });\n  };\n\n  PivotColDefService.prototype.recursivelyAddPivotTotal = function (groupDef, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter) {\n    var _this = this;\n\n    var group = groupDef;\n\n    if (!group.children) {\n      var def = groupDef;\n      return def.colId ? [def.colId] : null;\n    }\n\n    var colIds = []; // need to recurse children first to obtain colIds used in the aggregation stage\n\n    group.children.forEach(function (grp) {\n      var childColIds = _this.recursivelyAddPivotTotal(grp, pivotColumnDefs, columnIdSequence, valueColumn, insertAfter);\n\n      if (childColIds) {\n        colIds = colIds.concat(childColIds);\n      }\n    }); // only add total colDef if there is more than 1 child node\n\n    if (group.children.length > 1) {\n      //create total colDef using an arbitrary value column as a template\n      var totalColDef = this.createColDef(valueColumn, 'Total', groupDef.pivotKeys, columnIdSequence);\n      totalColDef.pivotTotalColumnIds = colIds;\n      totalColDef.aggFunc = valueColumn.getAggFunc(); // add total colDef to group and pivot colDefs array\n\n      var children = groupDef.children;\n      insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);\n      pivotColumnDefs.push(totalColDef);\n    }\n\n    return colIds;\n  };\n\n  PivotColDefService.prototype.addRowGroupTotals = function (pivotColumnGroupDefs, pivotColumnDefs, valueColumns, pivotColumns, columnIdSequence) {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.getPivotRowTotals()) {\n      return;\n    }\n\n    var insertAfter = this.gridOptionsWrapper.getPivotRowTotals() === 'after'; // order of row group totals depends on position\n\n    var valueCols = insertAfter ? valueColumns.slice() : valueColumns.slice().reverse();\n\n    var _loop_1 = function _loop_1(i) {\n      var valueCol = valueCols[i];\n      var colIds = [];\n      pivotColumnGroupDefs.forEach(function (groupDef) {\n        colIds = colIds.concat(_this.extractColIdsForValueColumn(groupDef, valueCol));\n      });\n      var levelsDeep = pivotColumns.length;\n      this_1.createRowGroupTotal(pivotColumnGroupDefs, pivotColumnDefs, 1, [], columnIdSequence, levelsDeep, pivotColumns, valueCol, colIds, insertAfter);\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < valueCols.length; i++) {\n      _loop_1(i);\n    }\n  };\n\n  PivotColDefService.prototype.extractColIdsForValueColumn = function (groupDef, valueColumn) {\n    var _this = this;\n\n    var group = groupDef;\n\n    if (!group.children) {\n      var colDef = group;\n      return colDef.pivotValueColumn === valueColumn && colDef.colId ? [colDef.colId] : [];\n    }\n\n    var colIds = [];\n    group.children.forEach(function (grp) {\n      _this.extractColIdsForValueColumn(grp, valueColumn);\n\n      var childColIds = _this.extractColIdsForValueColumn(grp, valueColumn);\n\n      colIds = colIds.concat(childColIds);\n    });\n    return colIds;\n  };\n\n  PivotColDefService.prototype.createRowGroupTotal = function (parentChildren, pivotColumnDefs, index, pivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns, valueColumn, colIds, insertAfter) {\n    var newPivotKeys = pivotKeys.slice(0);\n    var createGroup = index !== levelsDeep;\n\n    if (createGroup) {\n      var groupDef = {\n        children: [],\n        pivotKeys: newPivotKeys,\n        groupId: 'pivot' + columnIdSequence.next()\n      };\n      insertAfter ? parentChildren.push(groupDef) : parentChildren.unshift(groupDef);\n      this.createRowGroupTotal(groupDef.children, pivotColumnDefs, index + 1, newPivotKeys, columnIdSequence, levelsDeep, primaryPivotColumns, valueColumn, colIds, insertAfter);\n    } else {\n      var measureColumns = this.columnController.getValueColumns();\n      var valueGroup = {\n        children: [],\n        pivotKeys: newPivotKeys,\n        groupId: 'pivot' + columnIdSequence.next()\n      };\n\n      if (measureColumns.length === 0) {\n        var colDef = this.createColDef(null, '-', newPivotKeys, columnIdSequence);\n        valueGroup.children.push(colDef);\n        pivotColumnDefs.push(colDef);\n      } else {\n        var columnName = this.columnController.getDisplayNameForColumn(valueColumn, 'header');\n        var colDef = this.createColDef(valueColumn, columnName, newPivotKeys, columnIdSequence);\n        colDef.pivotTotalColumnIds = colIds;\n        valueGroup.children.push(colDef);\n        pivotColumnDefs.push(colDef);\n      }\n\n      insertAfter ? parentChildren.push(valueGroup) : parentChildren.unshift(valueGroup);\n    }\n  };\n\n  PivotColDefService.prototype.createColDef = function (valueColumn, headerName, pivotKeys, columnIdSequence) {\n    var colDef = {};\n\n    if (valueColumn) {\n      var colDefToCopy = valueColumn.getColDef();\n\n      ag_grid_community_1._.assign(colDef, colDefToCopy); // even if original column was hidden, we always show the pivot value column, otherwise it would be\n      // very confusing for people thinking the pivot is broken\n\n\n      colDef.hide = false;\n    }\n\n    colDef.headerName = headerName;\n    colDef.colId = 'pivot_' + columnIdSequence.next(); // pivot columns repeat over field, so it makes sense to use the unique id instead. For example if you want to\n    // assign values to pinned bottom rows using setPinnedBottomRowData the value service will use this colId.\n\n    colDef.field = colDef.colId;\n    colDef.pivotKeys = pivotKeys;\n    colDef.pivotValueColumn = valueColumn;\n    colDef.filter = false;\n    return colDef;\n  };\n\n  PivotColDefService.prototype.sameAggFuncs = function (aggFuncs) {\n    if (aggFuncs.length == 1) {\n      return true;\n    } //check if all aggFunc's match\n\n\n    for (var i = 1; i < aggFuncs.length; i++) {\n      if (aggFuncs[i] !== aggFuncs[0]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  PivotColDefService.prototype.headerNameComparator = function (userComparator, a, b) {\n    if (userComparator) {\n      return userComparator(a.headerName, b.headerName);\n    } else {\n      if (a.headerName && !b.headerName) {\n        return 1;\n      } else if (!a.headerName && b.headerName) {\n        return -1;\n      } // slightly naff here - just to satify typescript\n      // really should be &&, but if so ts complains\n      // the above if/else checks would deal with either being falsy, so at this stage if either are falsy, both are\n      // ..still naff though\n\n\n      if (!a.headerName || !b.headerName) {\n        return 0;\n      }\n\n      if (a.headerName < b.headerName) {\n        return -1;\n      } else if (a.headerName > b.headerName) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  };\n\n  __decorate([ag_grid_community_1.Autowired('columnController'), __metadata(\"design:type\", ag_grid_community_1.ColumnController)], PivotColDefService.prototype, \"columnController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)], PivotColDefService.prototype, \"gridOptionsWrapper\", void 0);\n\n  PivotColDefService = __decorate([ag_grid_community_1.Bean('pivotColDefService')], PivotColDefService);\n  return PivotColDefService;\n}();\n\nexports.PivotColDefService = PivotColDefService;","map":null,"metadata":{},"sourceType":"script"}