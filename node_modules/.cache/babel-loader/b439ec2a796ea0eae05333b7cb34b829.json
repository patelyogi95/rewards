{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar canvas_1 = require(\"./canvas/canvas\");\n\nvar angle_1 = require(\"./util/angle\");\n\nvar CanvasAxis =\n/** @class */\nfunction () {\n  function CanvasAxis(scale) {\n    this.translation = [0, 0];\n    this.rotation = 0; // radians\n\n    this.lineWidth = 1;\n    this.tickWidth = 1;\n    this.tickSize = 6;\n    this.tickPadding = 5;\n    this.lineColor = 'black';\n    this.tickColor = 'black';\n    this.labelFont = '14px Verdana';\n    this.labelColor = 'black';\n    this.flippedLabels = false;\n    this.mirroredLabels = false;\n    this.scale = scale;\n  } // To translate or rotate the axis the ctx can be transformed prior to render\n\n\n  CanvasAxis.prototype.render = function (ctx) {\n    ctx.save();\n    ctx.translate(this.translation[0], this.translation[1]);\n    ctx.rotate(this.rotation);\n    var scale = this.scale; // Render ticks and labels.\n\n    {\n      var ticks = scale.ticks(10);\n      var bandwidth = (scale.bandwidth || 0) / 2;\n      var tickCount = ticks.length;\n      var pxShift = canvas_1.pixelSnap(this.tickWidth);\n      var sideFlag = this.mirroredLabels ? 1 : -1;\n      ctx.lineWidth = this.tickWidth;\n      ctx.strokeStyle = this.tickColor;\n      ctx.fillStyle = this.labelColor;\n      ctx.textAlign = sideFlag === -1 ? 'end' : 'start';\n      ctx.textBaseline = 'middle';\n      ctx.font = this.labelFont;\n      ctx.beginPath();\n\n      for (var i = 0; i < tickCount; i++) {\n        var r = scale.convert(ticks[i]) - this.tickWidth / 2 + bandwidth;\n        ctx.moveTo(sideFlag * this.tickSize, r + pxShift);\n        ctx.lineTo(0, r + pxShift);\n\n        if (this.flippedLabels) {\n          var rotation = angle_1.normalizeAngle360(this.rotation);\n          var flipFlag = rotation >= 0 && rotation <= Math.PI ? -1 : 1;\n          ctx.save();\n          ctx.translate(sideFlag * (this.tickSize + this.tickPadding), r);\n          ctx.rotate(flipFlag * Math.PI / 2);\n          var labelWidth = ctx.measureText(ticks[i].toString()).width;\n          ctx.fillText(ticks[i].toString(), -sideFlag * labelWidth / 2, -sideFlag * flipFlag * this.tickPadding);\n          ctx.restore();\n        } else {\n          ctx.fillText(ticks[i].toString(), sideFlag * (this.tickSize + this.tickPadding), r);\n        }\n      }\n\n      ctx.stroke();\n    } // Render axis line.\n\n    {\n      var pxShift = canvas_1.pixelSnap(this.lineWidth, canvas_1.PixelSnapBias.Negative);\n      ctx.lineWidth = this.lineWidth;\n      ctx.strokeStyle = this.lineColor;\n      ctx.beginPath();\n      ctx.moveTo(pxShift, scale.range[0]);\n      ctx.lineTo(pxShift, scale.range[scale.range.length - 1]);\n      ctx.stroke();\n    }\n    ctx.restore();\n  };\n\n  return CanvasAxis;\n}();\n\nexports.CanvasAxis = CanvasAxis;","map":null,"metadata":{},"sourceType":"script"}