{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\"); // we cannot have 'null' as a key in a JavaScript map,\n// it needs to be a string. so we use this string for\n// storing null values.\n\n\nvar NULL_VALUE = '___NULL___';\nvar SetFilterModelValuesType;\n\n(function (SetFilterModelValuesType) {\n  SetFilterModelValuesType[SetFilterModelValuesType[\"PROVIDED_LIST\"] = 0] = \"PROVIDED_LIST\";\n  SetFilterModelValuesType[SetFilterModelValuesType[\"PROVIDED_CB\"] = 1] = \"PROVIDED_CB\";\n  SetFilterModelValuesType[SetFilterModelValuesType[\"NOT_PROVIDED\"] = 2] = \"NOT_PROVIDED\";\n})(SetFilterModelValuesType = exports.SetFilterModelValuesType || (exports.SetFilterModelValuesType = {}));\n\nvar SetFilterModel =\n/** @class */\nfunction () {\n  function SetFilterModel(colDef, rowModel, valueGetter, doesRowPassOtherFilters, suppressSorting, modelUpdatedFunc, isLoadingFunc, valueFormatterService, column) {\n    this.suppressSorting = suppressSorting;\n    this.colDef = colDef;\n    this.valueGetter = valueGetter;\n    this.doesRowPassOtherFilters = doesRowPassOtherFilters;\n    this.modelUpdatedFunc = modelUpdatedFunc;\n    this.isLoadingFunc = isLoadingFunc;\n    this.valueFormatterService = valueFormatterService;\n    this.column = column;\n\n    if (rowModel.getType() === ag_grid_community_1.Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n      this.clientSideRowModel = rowModel;\n    }\n\n    this.filterParams = this.colDef.filterParams ? this.colDef.filterParams : {};\n\n    if (ag_grid_community_1._.exists(this.filterParams) && ag_grid_community_1._.exists(this.filterParams.values)) {\n      this.valuesType = Array.isArray(this.filterParams.values) ? SetFilterModelValuesType.PROVIDED_LIST : SetFilterModelValuesType.PROVIDED_CB;\n      this.showingAvailableOnly = this.filterParams.suppressRemoveEntries !== true;\n    } else {\n      this.valuesType = SetFilterModelValuesType.NOT_PROVIDED;\n      this.showingAvailableOnly = true;\n    }\n\n    this.createAllUniqueValues();\n    this.createAvailableUniqueValues(); // by default, no filter, so we display everything\n\n    this.displayedValues = this.availableUniqueValues;\n    this.miniFilter = null; // we use a map rather than an array for the selected values as the lookup\n    // for a map is much faster than the lookup for an array, especially when\n    // the length of the array is thousands of records long\n\n    this.selectedValuesMap = {};\n    this.selectEverything();\n    this.formatter = this.filterParams.textFormatter ? this.filterParams.textFormatter : ag_grid_community_1.TextFilter.DEFAULT_FORMATTER;\n  } // if keepSelection not set will always select all filters\n  // if keepSelection set will keep current state of selected filters\n  //    unless selectAll chosen in which case will select all\n\n\n  SetFilterModel.prototype.refreshAfterNewRowsLoaded = function (keepSelection, isSelectAll) {\n    this.createAllUniqueValues();\n    this.refreshSelection(keepSelection, isSelectAll);\n  }; // if keepSelection not set will always select all filters\n  // if keepSelection set will keep current state of selected filters\n  //    unless selectAll chosen in which case will select all\n\n\n  SetFilterModel.prototype.refreshValues = function (valuesToUse, keepSelection, isSelectAll) {\n    this.setValues(valuesToUse);\n    this.refreshSelection(keepSelection, isSelectAll);\n  };\n\n  SetFilterModel.prototype.refreshSelection = function (keepSelection, isSelectAll) {\n    this.createAvailableUniqueValues();\n    var oldModel = Object.keys(this.selectedValuesMap);\n    this.selectedValuesMap = {};\n    this.processMiniFilter();\n\n    if (keepSelection) {\n      this.setModel(oldModel, isSelectAll);\n    } else {\n      this.selectEverything();\n    }\n  };\n\n  SetFilterModel.prototype.refreshAfterAnyFilterChanged = function () {\n    if (this.showingAvailableOnly) {\n      this.createAvailableUniqueValues();\n      this.processMiniFilter();\n    }\n  };\n\n  SetFilterModel.prototype.createAllUniqueValues = function () {\n    if (this.areValuesSync()) {\n      var valuesToUse = this.extractSyncValuesToUse();\n      this.setValues(valuesToUse);\n      this.filterValuesPromise = ag_grid_community_1.Promise.resolve([]);\n    } else {\n      this.filterValuesExternalPromise = ag_grid_community_1.Promise.external();\n      this.filterValuesPromise = this.filterValuesExternalPromise.promise;\n      this.isLoadingFunc(true);\n      this.setValues([]);\n      var callback_1 = this.filterParams.values;\n      var params_1 = {\n        success: this.onAsyncValuesLoaded.bind(this),\n        colDef: this.colDef\n      };\n      window.setTimeout(function () {\n        return callback_1(params_1);\n      }, 0);\n    }\n  };\n\n  SetFilterModel.prototype.onAsyncValuesLoaded = function (values) {\n    this.modelUpdatedFunc(values);\n    this.isLoadingFunc(false);\n    this.filterValuesExternalPromise.resolve(values);\n  };\n\n  SetFilterModel.prototype.areValuesSync = function () {\n    return this.valuesType == SetFilterModelValuesType.PROVIDED_LIST || this.valuesType == SetFilterModelValuesType.NOT_PROVIDED;\n  };\n\n  SetFilterModel.prototype.setValuesType = function (value) {\n    this.valuesType = value;\n  };\n\n  SetFilterModel.prototype.setValues = function (valuesToUse) {\n    this.allUniqueValues = valuesToUse;\n\n    if (!this.suppressSorting) {\n      this.sortValues(this.allUniqueValues);\n    }\n  };\n\n  SetFilterModel.prototype.extractSyncValuesToUse = function () {\n    var valuesToUse;\n\n    if (this.valuesType == SetFilterModelValuesType.PROVIDED_LIST) {\n      if (Array.isArray(this.filterParams.values)) {\n        valuesToUse = ag_grid_community_1._.toStrings(this.filterParams.values);\n      } else {\n        // In this case the values are async but have already been resolved, so we can reuse them\n        valuesToUse = this.allUniqueValues;\n      }\n    } else if (this.valuesType == SetFilterModelValuesType.PROVIDED_CB) {\n      throw Error(\"ag-grid: Error extracting values to use. We should not extract the values synchronously when using a callback for the filterParams.values\");\n    } else {\n      var uniqueValuesAsAnyObjects = this.getUniqueValues(false);\n      valuesToUse = ag_grid_community_1._.toStrings(uniqueValuesAsAnyObjects);\n    }\n\n    return valuesToUse;\n  };\n\n  SetFilterModel.prototype.createAvailableUniqueValues = function () {\n    var dontCheckAvailableValues = !this.showingAvailableOnly || this.valuesType == SetFilterModelValuesType.PROVIDED_LIST || this.valuesType == SetFilterModelValuesType.PROVIDED_CB;\n\n    if (dontCheckAvailableValues) {\n      this.availableUniqueValues = this.allUniqueValues;\n      return;\n    }\n\n    var uniqueValuesAsAnyObjects = this.getUniqueValues(true);\n    this.availableUniqueValues = ag_grid_community_1._.toStrings(uniqueValuesAsAnyObjects);\n    this.sortValues(this.availableUniqueValues);\n  };\n\n  SetFilterModel.prototype.sortValues = function (values) {\n    if (this.filterParams && this.filterParams.comparator) {\n      values.sort(this.filterParams.comparator);\n    } else if (this.colDef.comparator) {\n      values.sort(this.colDef.comparator);\n    } else {\n      values.sort(ag_grid_community_1._.defaultComparator);\n    }\n  };\n\n  SetFilterModel.prototype.getUniqueValues = function (filterOutNotAvailable) {\n    var _this = this;\n\n    var uniqueCheck = {};\n    var result = [];\n\n    if (!this.clientSideRowModel) {\n      console.error('ag-Grid: Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values');\n      return [];\n    }\n\n    this.clientSideRowModel.forEachLeafNode(function (node) {\n      // only pull values from rows that have data. this means we skip filler group nodes.\n      if (!node.data) {\n        return;\n      }\n\n      var value = _this.valueGetter(node);\n\n      if (_this.colDef.keyCreator) {\n        value = _this.colDef.keyCreator({\n          value: value\n        });\n      }\n\n      if (value === \"\" || value === undefined) {\n        value = null;\n      }\n\n      if (filterOutNotAvailable) {\n        if (!_this.doesRowPassOtherFilters(node)) {\n          return;\n        }\n      }\n\n      if (value != null && Array.isArray(value)) {\n        for (var j = 0; j < value.length; j++) {\n          addUniqueValueIfMissing(value[j]);\n        }\n      } else {\n        addUniqueValueIfMissing(value);\n      }\n    });\n\n    function addUniqueValueIfMissing(value) {\n      if (!uniqueCheck.hasOwnProperty(value)) {\n        result.push(value);\n        uniqueCheck[value] = 1;\n      }\n    }\n\n    return result;\n  }; //sets mini filter. returns true if it changed from last value, otherwise false\n\n\n  SetFilterModel.prototype.setMiniFilter = function (newMiniFilter) {\n    newMiniFilter = ag_grid_community_1._.makeNull(newMiniFilter);\n\n    if (this.miniFilter === newMiniFilter) {\n      //do nothing if filter has not changed\n      return false;\n    }\n\n    this.miniFilter = newMiniFilter;\n    this.processMiniFilter();\n    return true;\n  };\n\n  SetFilterModel.prototype.getMiniFilter = function () {\n    return this.miniFilter;\n  };\n\n  SetFilterModel.prototype.processMiniFilter = function () {\n    // if no filter, just use the unique values\n    if (this.miniFilter === null) {\n      this.displayedValues = this.availableUniqueValues;\n      return;\n    } // if filter present, we filter down the list\n\n\n    this.displayedValues = [];\n    var miniFilter = this.formatter(this.miniFilter); // make upper case to have search case insensitive\n\n    var miniFilterUpperCase = miniFilter.toUpperCase(); //This function encapsulates the logic to check if a string matches the mini filter\n\n    var matchesFn = function matchesFn(valueToCheck) {\n      if (valueToCheck == null) {\n        return false;\n      } // allow for case insensitive searches, make both filter and value uppercase\n\n\n      var valueUpperCase = valueToCheck.toUpperCase();\n      return valueUpperCase.indexOf(miniFilterUpperCase) >= 0;\n    };\n\n    for (var i = 0, l = this.availableUniqueValues.length; i < l; i++) {\n      var value = this.availableUniqueValues[i];\n\n      if (value) {\n        var displayedValue = this.formatter(value.toString());\n        var formattedValue = this.valueFormatterService.formatValue(this.column, null, null, displayedValue);\n\n        if (matchesFn(displayedValue) || matchesFn(formattedValue)) {\n          this.displayedValues.push(value);\n        }\n      }\n    }\n  };\n\n  SetFilterModel.prototype.getDisplayedValueCount = function () {\n    return this.displayedValues.length;\n  };\n\n  SetFilterModel.prototype.getDisplayedValue = function (index) {\n    return this.displayedValues[index];\n  };\n\n  SetFilterModel.prototype.selectEverything = function () {\n    if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n      this.selectOn(this.allUniqueValues);\n    } else {\n      this.selectOn(this.displayedValues);\n    }\n  };\n\n  SetFilterModel.prototype.selectOn = function (toSelectOn) {\n    var count = toSelectOn.length;\n\n    for (var i = 0; i < count; i++) {\n      var key = toSelectOn[i];\n      var safeKey = this.valueToKey(key);\n      this.selectedValuesMap[safeKey] = null;\n    }\n\n    this.selectedValuesCount = count;\n  };\n\n  SetFilterModel.prototype.valueToKey = function (key) {\n    if (key === null) {\n      return NULL_VALUE;\n    } else {\n      return key;\n    }\n  };\n\n  SetFilterModel.prototype.keyToValue = function (value) {\n    if (value === NULL_VALUE) {\n      return null;\n    } else {\n      return value;\n    }\n  };\n\n  SetFilterModel.prototype.isFilterActive = function () {\n    return this.allUniqueValues.length !== this.selectedValuesCount;\n  };\n\n  SetFilterModel.prototype.selectNothing = function () {\n    var _this = this;\n\n    if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n      this.selectedValuesMap = {};\n      this.selectedValuesCount = 0;\n    } else {\n      this.displayedValues.forEach(function (it) {\n        return _this.unselectValue(it);\n      });\n    }\n  };\n\n  SetFilterModel.prototype.getUniqueValueCount = function () {\n    return this.allUniqueValues.length;\n  };\n\n  SetFilterModel.prototype.getUniqueValue = function (index) {\n    return this.allUniqueValues[index];\n  };\n\n  SetFilterModel.prototype.unselectValue = function (value) {\n    var safeKey = this.valueToKey(value);\n\n    if (this.selectedValuesMap[safeKey] !== undefined) {\n      delete this.selectedValuesMap[safeKey];\n      this.selectedValuesCount--;\n    }\n  };\n\n  SetFilterModel.prototype.selectValue = function (value) {\n    var safeKey = this.valueToKey(value);\n\n    if (this.selectedValuesMap[safeKey] === undefined) {\n      this.selectedValuesMap[safeKey] = null;\n      this.selectedValuesCount++;\n    }\n  };\n\n  SetFilterModel.prototype.isValueSelected = function (value) {\n    var safeKey = this.valueToKey(value);\n    return this.selectedValuesMap[safeKey] !== undefined;\n  };\n\n  SetFilterModel.prototype.isEverythingSelected = function () {\n    var _this = this;\n\n    if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n      return this.allUniqueValues.length === this.selectedValuesCount;\n    } else {\n      return this.displayedValues.filter(function (it) {\n        return _this.isValueSelected(it);\n      }).length === this.displayedValues.length;\n    }\n  };\n\n  SetFilterModel.prototype.isNothingSelected = function () {\n    var _this = this;\n\n    if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n      return this.selectedValuesCount === 0;\n    } else {\n      return this.displayedValues.filter(function (it) {\n        return _this.isValueSelected(it);\n      }).length === 0;\n    }\n  };\n\n  SetFilterModel.prototype.getModel = function () {\n    var _this = this;\n\n    if (!this.isFilterActive()) {\n      return null;\n    }\n\n    var selectedValues = [];\n\n    ag_grid_community_1._.iterateObject(this.selectedValuesMap, function (key) {\n      var value = _this.keyToValue(key);\n\n      selectedValues.push(value);\n    });\n\n    return selectedValues;\n  };\n\n  SetFilterModel.prototype.setModel = function (model, isSelectAll) {\n    var _this = this;\n\n    if (isSelectAll === void 0) {\n      isSelectAll = false;\n    }\n\n    if (this.areValuesSync()) {\n      this.setSyncModel(model, isSelectAll);\n    } else {\n      this.filterValuesExternalPromise.promise.then(function (values) {\n        _this.setSyncModel(model, isSelectAll);\n\n        _this.modelUpdatedFunc(values, model);\n      });\n    }\n  };\n\n  SetFilterModel.prototype.setSyncModel = function (model, isSelectAll) {\n    if (isSelectAll === void 0) {\n      isSelectAll = false;\n    }\n\n    if (model && !isSelectAll) {\n      this.selectNothing();\n\n      for (var i = 0; i < model.length; i++) {\n        var rawValue = model[i];\n        var value = this.keyToValue(rawValue);\n\n        if (this.allUniqueValues.indexOf(value) >= 0) {\n          this.selectValue(value);\n        }\n      }\n    } else {\n      this.selectEverything();\n    }\n  };\n\n  SetFilterModel.prototype.onFilterValuesReady = function (callback) {\n    //This guarantees that if the user is racing to set values async into the set filter, only the first instance\n    //will be used\n    // ie Values are async and the user manually wants to override them before the retrieval of values is triggered\n    // (set filter values in the following example)\n    // http://plnkr.co/edit/eFka7ynvPj68tL3VJFWf?p=preview\n    this.filterValuesPromise.firstOneOnly(callback);\n  };\n\n  return SetFilterModel;\n}();\n\nexports.SetFilterModel = SetFilterModel;","map":null,"metadata":{},"sourceType":"script"}