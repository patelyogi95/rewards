{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * As of Jan 8, 2019, Firefox still doesn't implement\n * `getTransform(): DOMMatrix;`\n * `setTransform(transform?: DOMMatrix2DInit)`\n * in the `CanvasRenderingContext2D`.\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\n * IE11 and Edge 44 also don't have the support.\n * Thus this class, to keep track of the current transform and\n * combine transformations.\n * Standards:\n * https://html.spec.whatwg.org/dev/canvas.html\n * https://www.w3.org/TR/geometry-1/\n */\n\nvar Matrix =\n/** @class */\nfunction () {\n  function Matrix(elements) {\n    if (elements === void 0) {\n      elements = [1, 0, 0, 1, 0, 0];\n    }\n\n    this._a = 1;\n    this._b = 0;\n    this._c = 0;\n    this._d = 1;\n    this._e = 0;\n    this._f = 0;\n    this.elements = elements;\n  }\n\n  Matrix.prototype.setElements = function (elements) {\n    var e = this.elements; // `this.elements = elements.slice()` is 4-5 times slower\n    // (in Chrome 71 and FF 64) than manually copying elements,\n    // since slicing allocates new memory.\n    // The performance of passing parameters individually\n    // vs as an array is about the same in both browsers, so we\n    // go with a single (array of elements) parameter, because\n    // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\n    // calls give us roughly the same performance, versus\n    // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\n    // where the spread operator causes a 20-30x performance drop\n    // (30x when compiled to ES5's `.apply(this, elements)`\n    //  20x when used natively).\n\n    e[0] = elements[0];\n    e[1] = elements[1];\n    e[2] = elements[2];\n    e[3] = elements[3];\n    e[4] = elements[4];\n    e[5] = elements[5];\n    return this;\n  };\n\n  Matrix.prototype.setIdentityElements = function () {\n    var e = this.elements;\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 1;\n    e[4] = 0;\n    e[5] = 0;\n    return this;\n  };\n\n  Object.defineProperty(Matrix.prototype, \"identity\", {\n    get: function get() {\n      var e = this.elements;\n      return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"a\", {\n    get: function get() {\n      return this.elements[0];\n    },\n    set: function set(value) {\n      this.elements[0] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"b\", {\n    get: function get() {\n      return this.elements[1];\n    },\n    set: function set(value) {\n      this.elements[1] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"c\", {\n    get: function get() {\n      return this.elements[2];\n    },\n    set: function set(value) {\n      this.elements[2] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"d\", {\n    get: function get() {\n      return this.elements[3];\n    },\n    set: function set(value) {\n      this.elements[3] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"e\", {\n    get: function get() {\n      return this.elements[4];\n    },\n    set: function set(value) {\n      this.elements[4] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"f\", {\n    get: function get() {\n      return this.elements[5];\n    },\n    set: function set(value) {\n      this.elements[5] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n\n  Matrix.prototype.AxB = function (A, B, C) {\n    var m11 = A[0],\n        m12 = A[1],\n        m21 = A[2],\n        m22 = A[3],\n        m31 = A[4],\n        m32 = A[5];\n    var o11 = B[0],\n        o12 = B[1],\n        o21 = B[2],\n        o22 = B[3],\n        o31 = B[4],\n        o32 = B[5];\n    C = C || A;\n    C[0] = m11 * o11 + m21 * o12;\n    C[1] = m12 * o11 + m22 * o12;\n    C[2] = m11 * o21 + m21 * o22;\n    C[3] = m12 * o21 + m22 * o22;\n    C[4] = m11 * o31 + m21 * o32 + m31;\n    C[5] = m12 * o31 + m22 * o32 + m32;\n  };\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n\n\n  Matrix.prototype.multiplySelf = function (other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  };\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n\n\n  Matrix.prototype.multiply = function (other) {\n    var elements = new Array(6);\n    this.AxB(this.elements, other.elements, elements);\n    return new Matrix(elements);\n  };\n\n  Matrix.prototype.preMultiplySelf = function (other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  };\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n\n\n  Matrix.prototype.inverse = function () {\n    var _g = this.elements,\n        a = _g[0],\n        b = _g[1],\n        c = _g[2],\n        d = _g[3],\n        e = _g[4],\n        f = _g[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  };\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n\n\n  Matrix.prototype.inverseTo = function (other) {\n    var _g = this.elements,\n        a = _g[0],\n        b = _g[1],\n        c = _g[2],\n        d = _g[3],\n        e = _g[4],\n        f = _g[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  };\n\n  Matrix.prototype.invertSelf = function () {\n    var elements = this.elements;\n    var a = elements[0],\n        b = elements[1],\n        c = elements[2],\n        d = elements[3],\n        e = elements[4],\n        f = elements[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    elements[0] = d;\n    elements[1] = -b;\n    elements[2] = -c;\n    elements[3] = a;\n    elements[4] = c * f - d * e;\n    elements[5] = b * e - a * f;\n    return this;\n  };\n\n  Matrix.prototype.clone = function () {\n    return new Matrix(this.elements.slice());\n  };\n\n  Matrix.prototype.transformPoint = function (x, y) {\n    var e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  };\n\n  Matrix.prototype.toContext = function (ctx) {\n    // It's fair to say that matrix multiplications are not cheap.\n    // However, updating path definitions on every frame isn't either, so\n    // it may be cheaper to just translate paths. It's also fair to\n    // say, that most paths will have to be re-rendered anyway, say\n    // rectangle paths in a bar chart, where an animation would happen when\n    // the data set changes and existing bars are morphed into new ones.\n    // Or a pie chart, where old sectors are also morphed into new ones.\n    // Same for the line chart. The only plausible case where translating\n    // existing paths would be enough, is the scatter chart, where marker\n    // icons, typically circles, stay the same size. But if circle radii\n    // are bound to some data points, even circle paths would have to be\n    // updated. And thus it makes sense to optimize for fewer matrix\n    // transforms, where transform matrices of paths are mostly identity\n    // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\n    // are used to define a path at specific coordinates. And only groups\n    // are used to collectively apply a transform to a set of nodes.\n    // If the matrix is mostly identity (95% of the time),\n    // the `if (this.isIdentity)` check can make this call 3-4 times\n    // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\n    if (this.identity) return;\n    var e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  };\n\n  Matrix.flyweight = function (elements) {\n    if (elements) {\n      if (elements instanceof Matrix) Matrix.matrix.setElements(elements.elements);else Matrix.matrix.setElements(elements);\n    } else Matrix.matrix.setIdentityElements();\n    return Matrix.matrix;\n  };\n\n  Matrix.matrix = new Matrix();\n  return Matrix;\n}();\n\nexports.Matrix = Matrix;","map":null,"metadata":{},"sourceType":"script"}