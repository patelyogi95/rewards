{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar matrix_1 = require(\"./matrix\");\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  function Node() {\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    this.id = this.createId();\n    /**\n     * Some number to identify this node, typically within a `Group` node.\n     * Usually this will be some enum value used as a selector.\n     */\n\n    this.tag = NaN;\n    this._scene = null;\n    this._parent = null;\n    this._children = []; // Used to check for duplicate nodes.\n\n    this.childSet = {}; // new Set<Node>()\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n\n    this.matrix = new matrix_1.Matrix();\n    this.inverseMatrix = new matrix_1.Matrix(); // TODO: should this be `true` by default as well?\n\n    this._dirtyTransform = false;\n    this._scalingX = 1;\n    this._scalingY = 1;\n    /**\n     * The center of scaling.\n     * The default value of `null` means the scaling center will be\n     * determined automatically, as the center of the bounding box\n     * of a node.\n     */\n\n    this._scalingCenterX = null;\n    this._scalingCenterY = null;\n    this._rotationCenterX = null;\n    this._rotationCenterY = null;\n    /**\n     * Rotation angle in radians.\n     * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n     * interval is performed.\n     */\n\n    this._rotation = 0;\n    this._translationX = 0;\n    this._translationY = 0;\n    /**\n     * Each time a property of the node that effects how it renders changes\n     * the `dirty` property of the node should be set to `true`. The change\n     * to the `dirty` property of the node will propagate up to its parents\n     * and eventually to the scene, at which point an animation frame callback\n     * will be scheduled to rerender the scene and its nodes and reset the `dirty`\n     * flags of all nodes and the {@link Scene._dirty | Scene} back to `false`.\n     * Since changes to node properties are not rendered immediately, it's possible\n     * to change as many properties on as many nodes as needed and the rendering\n     * will still only happen once in the next animation frame callback.\n     * The animation frame callback is only scheduled if it hasn't been already.\n     */\n\n    this._dirty = true;\n    this._visible = true;\n  } // TODO: what does ag-Grid use for component identification?\n  // Uniquely identify nodes (to check for duplicates, for example).\n\n\n  Node.prototype.createId = function () {\n    var constructor = this.constructor;\n    var name = constructor.name;\n\n    if (!name) {\n      // IE11\n      var match = constructor.toString().match(Node.fnNameRegex);\n\n      if (match) {\n        constructor.name = name = match[1];\n      } else {\n        throw new Error(\"Couldn't get the constructor's name: \" + constructor);\n      }\n    }\n\n    return name + '-' + (constructor.id = (constructor.id || 0) + 1);\n  };\n\n  ;\n\n  Node.isNode = function (node) {\n    return node ? node.matrix !== undefined : false;\n  };\n\n  Node.prototype._setScene = function (value) {\n    this._scene = value;\n    var children = this.children;\n    var n = children.length;\n\n    for (var i = 0; i < n; i++) {\n      children[i]._setScene(value);\n    }\n  };\n\n  Object.defineProperty(Node.prototype, \"scene\", {\n    get: function get() {\n      return this._scene;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype._setParent = function (value) {\n    this._parent = value;\n  };\n\n  Object.defineProperty(Node.prototype, \"parent\", {\n    get: function get() {\n      return this._parent;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"children\", {\n    get: function get() {\n      return this._children;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.countChildren = function (depth) {\n    if (depth === void 0) {\n      depth = Node.MAX_SAFE_INTEGER;\n    }\n\n    if (depth <= 0) return 0;\n    var children = this.children;\n    var n = children.length;\n    var size = n;\n\n    for (var i = 0; i < n; i++) {\n      size += children[i].countChildren(depth - 1);\n    }\n\n    return size;\n  };\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n\n\n  Node.prototype.append = function (nodes) {\n    // Passing a single parameter to an open-ended version of `append`\n    // would be 30-35% slower than this.\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    } // The function takes an array rather than having open-ended\n    // arguments like `...nodes: Node[]` because the latter is\n    // transpiled to a function where the `arguments` object\n    // is copied to a temporary array inside a loop.\n    // So an array is created either way. And if we already have\n    // an array of nodes we want to add, we have to use the prohibitively\n    // expensive spread operator to pass it to the function,\n    // and, on top of that, the copy of the `arguments` is still made.\n\n\n    var n = nodes.length;\n\n    for (var i = 0; i < n; i++) {\n      var node = nodes[i];\n\n      if (node.parent) {\n        throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n      }\n\n      if (node.scene) {\n        throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n      }\n\n      if (this.childSet[node.id]) {\n        // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n        throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n      }\n\n      this._children.push(node);\n\n      this.childSet[node.id] = true;\n\n      node._setParent(this);\n\n      node._setScene(this.scene);\n    }\n\n    this.dirty = true;\n  };\n\n  Node.prototype.appendChild = function (node) {\n    if (node.parent) {\n      throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n    }\n\n    if (node.scene) {\n      throw new Error(node + \" already belongs a scene: \" + node.scene + \".\");\n    }\n\n    if (this.childSet[node.id]) {\n      // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n      throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n    }\n\n    this._children.push(node);\n\n    this.childSet[node.id] = true;\n\n    node._setParent(this);\n\n    node._setScene(this.scene);\n\n    this.dirty = true;\n    return node;\n  };\n\n  Node.prototype.removeChild = function (node) {\n    if (node.parent === this) {\n      var i = this.children.indexOf(node);\n\n      if (i >= 0) {\n        this._children.splice(i, 1);\n\n        delete this.childSet[node.id];\n\n        node._setParent(null);\n\n        node._setScene(null);\n\n        this.dirty = true;\n        return node;\n      }\n    }\n\n    throw new Error(\"The node to be removed is not a child of this node.\");\n  };\n  /**\n   * Inserts the node `node` before the existing child node `nextNode`.\n   * If `nextNode` is null, insert `node` at the end of the list of children.\n   * If the `node` belongs to another parent, it is first removed.\n   * Returns the `node`.\n   * @param node\n   * @param nextNode\n   */\n\n\n  Node.prototype.insertBefore = function (node, nextNode) {\n    var parent = node.parent;\n\n    if (node.parent) {\n      node.parent.removeChild(node);\n    }\n\n    if (nextNode && nextNode.parent === this) {\n      var i = this.children.indexOf(nextNode);\n\n      if (i >= 0) {\n        this._children.splice(i, 0, node);\n\n        this.childSet[node.id] = true;\n\n        node._setParent(this);\n\n        node._setScene(this.scene);\n      } else {\n        throw new Error(nextNode + \" has \" + parent + \" as the parent, \" + \"but is not in its list of children.\");\n      }\n\n      this.dirty = true;\n    } else {\n      this.append(node);\n    }\n\n    return node;\n  };\n  /**\n   * Calculates the combined inverse transformation for this node,\n   * and uses it to convert the given transformed point\n   * to the untransformed one.\n   * @param x\n   * @param y\n   */\n\n\n  Node.prototype.transformPoint = function (x, y) {\n    var matrix = matrix_1.Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n\n    while (parent) {\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n\n    return matrix.invertSelf().transformPoint(x, y);\n  };\n\n  Object.defineProperty(Node.prototype, \"dirtyTransform\", {\n    get: function get() {\n      return this._dirtyTransform;\n    },\n    set: function set(value) {\n      this._dirtyTransform = value; // TODO: replace this with simply `this.dirty = true`,\n      //       see `set dirty` method.\n\n      if (value) {\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingX\", {\n    get: function get() {\n      return this._scalingX;\n    },\n    set: function set(value) {\n      if (this._scalingX !== value) {\n        this._scalingX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingY\", {\n    get: function get() {\n      return this._scalingY;\n    },\n    set: function set(value) {\n      if (this._scalingY !== value) {\n        this._scalingY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingCenterX\", {\n    get: function get() {\n      return this._scalingCenterX;\n    },\n    set: function set(value) {\n      if (this._scalingCenterX !== value) {\n        this._scalingCenterX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"scalingCenterY\", {\n    get: function get() {\n      return this._scalingCenterY;\n    },\n    set: function set(value) {\n      if (this._scalingCenterY !== value) {\n        this._scalingCenterY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationCenterX\", {\n    get: function get() {\n      return this._rotationCenterX;\n    },\n    set: function set(value) {\n      if (this._rotationCenterX !== value) {\n        this._rotationCenterX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationCenterY\", {\n    get: function get() {\n      return this._rotationCenterY;\n    },\n    set: function set(value) {\n      if (this._rotationCenterY !== value) {\n        this._rotationCenterY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotation\", {\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(value) {\n      if (this._rotation !== value) {\n        this._rotation = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"rotationDeg\", {\n    get: function get() {\n      return this.rotation / Math.PI * 180;\n    },\n\n    /**\n     * For performance reasons the rotation angle's internal representation\n     * is in radians. Therefore, don't expect to get the same number you set.\n     * Even with integer angles about a quarter of them from 0 to 359 cannot\n     * be converted to radians and back without precision loss.\n     * For example:\n     *\n     *     node.rotationDeg = 11;\n     *     console.log(node.rotationDeg); // 10.999999999999998\n     *\n     * @param value Rotation angle in degrees.\n     */\n    set: function set(value) {\n      this.rotation = value / 180 * Math.PI;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"translationX\", {\n    get: function get() {\n      return this._translationX;\n    },\n    set: function set(value) {\n      if (this._translationX !== value) {\n        this._translationX = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"translationY\", {\n    get: function get() {\n      return this._translationY;\n    },\n    set: function set(value) {\n      if (this._translationY !== value) {\n        this._translationY = value;\n        this.dirtyTransform = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.isPointInNode = function (x, y) {\n    return false;\n  };\n\n  Node.prototype.getBBoxCenter = function () {\n    var bbox = this.getBBox && this.getBBox();\n\n    if (bbox) {\n      return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];\n    }\n\n    return [0, 0];\n  };\n\n  Node.prototype.computeTransformMatrix = function () {\n    // TODO: transforms without center of scaling and rotation correspond directly\n    //       to `setAttribute('transform', 'translate(tx, ty) rotate(rDeg) scale(sx, sy)')`\n    //       in SVG. Our use cases will mostly require positioning elements (rects, circles)\n    //       within a group, rotating groups at right angles (e.g. for axis) and translating\n    //       groups. We shouldn't even need `scale(1, -1)` (invert vertically), since this\n    //       can be done using D3-like scales already by inverting the output range.\n    //       So for now, just assume that centers of scaling and rotation are at the origin.\n    // const [bbcx, bbcy] = this.getBBoxCenter();\n    var _a = [0, 0],\n        bbcx = _a[0],\n        bbcy = _a[1];\n    var sx = this.scalingX;\n    var sy = this.scalingY;\n    var scx;\n    var scy;\n\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = this.scalingCenterX === null ? bbcx : this.scalingCenterX;\n      scy = this.scalingCenterY === null ? bbcy : this.scalingCenterY;\n    }\n\n    var r = this.rotation;\n    var cos = Math.cos(r);\n    var sin = Math.sin(r);\n    var rcx;\n    var rcy;\n\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = this.rotationCenterX === null ? bbcx : this.rotationCenterX;\n      rcy = this.rotationCenterY === null ? bbcy : this.rotationCenterY;\n    }\n\n    var tx = this.translationX;\n    var ty = this.translationY; // The transform matrix `M` is a result of the following transformations:\n    // 1) translate the center of scaling to the origin\n    // 2) scale\n    // 3) translate back\n    // 4) translate the center of rotation to the origin\n    // 5) rotate\n    // 6) translate back\n    // 7) translate\n    //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n    //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n    // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n    //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n    // Translation after steps 1-4 above:\n\n    var tx4 = scx * (1 - sx) - rcx;\n    var ty4 = scy * (1 - sy) - rcy;\n    this.dirtyTransform = false;\n    this.matrix.setElements([cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx4 - sin * ty4 + rcx + tx, sin * tx4 + cos * ty4 + rcy + ty]).inverseTo(this.inverseMatrix);\n  };\n\n  Object.defineProperty(Node.prototype, \"dirty\", {\n    get: function get() {\n      return this._dirty;\n    },\n    set: function set(value) {\n      // TODO: check if we are already dirty (e.g. if (this._dirty !== value))\n      //       if we are, then all parents and the scene have been\n      //       notified already, and we are doing redundant work\n      //       (but test if this is indeed the case)\n      this._dirty = value;\n\n      if (value) {\n        if (this.parent) {\n          this.parent.dirty = true;\n        } else if (this.scene) {\n          this.scene.dirty = true;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"visible\", {\n    get: function get() {\n      return this._visible;\n    },\n    set: function set(value) {\n      if (this._visible !== value) {\n        this._visible = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.fnNameRegex = /function (\\w+)\\(/;\n  Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n\n  return Node;\n}();\n\nexports.Node = Node;","map":null,"metadata":{},"sourceType":"script"}