{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Wraps the native Canvas element and overrides its CanvasRenderingContext2D to\n * provide resolution independent rendering based on `window.devicePixelRatio`.\n */\n\nvar HdpiCanvas =\n/** @class */\nfunction () {\n  // The width/height attributes of the Canvas element default to\n  // 300/150 according to w3.org.\n  function HdpiCanvas(width, height) {\n    if (width === void 0) {\n      width = 300;\n    }\n\n    if (height === void 0) {\n      height = 150;\n    }\n\n    this._parent = null;\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d'); // `NaN` is deliberate here, so that overrides are always applied\n    // and the `resetTransform` inside the `resize` method works in IE11.\n\n    this._pixelRatio = NaN;\n    this.updatePixelRatio(0, false);\n    this.resize(width, height);\n  }\n\n  Object.defineProperty(HdpiCanvas.prototype, \"parent\", {\n    get: function get() {\n      return this._parent;\n    },\n    set: function set(value) {\n      if (this._parent !== value) {\n        this.remove();\n\n        if (value) {\n          value.appendChild(this.canvas);\n        }\n\n        this._parent = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  HdpiCanvas.prototype.remove = function () {\n    var parent = this.canvas.parentNode;\n\n    if (parent !== null) {\n      parent.removeChild(this.canvas);\n    }\n  };\n\n  HdpiCanvas.prototype.destroy = function () {\n    this.canvas.remove();\n    this._canvas = undefined;\n    Object.freeze(this);\n  };\n\n  HdpiCanvas.prototype.toImage = function () {\n    var img = document.createElement('img');\n    img.src = this.canvas.toDataURL();\n    return img;\n  };\n  /**\n   * @param fileName The `.png` extension is going to be added automatically.\n   */\n\n\n  HdpiCanvas.prototype.download = function (fileName) {\n    // Chart images saved as JPEG are a few times larger at 50% quality than PNG images,\n    // so we don't support saving to JPEG.\n    var type = 'image/png'; // The background of our canvas is transparent, so we create a temporary canvas\n    // with the white background and paint our canvas on top of it.\n\n    var canvas = document.createElement('canvas');\n    canvas.width = this.canvas.width;\n    canvas.height = this.canvas.height;\n    var ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.drawImage(this.canvas, 0, 0);\n    var dataUrl = canvas.toDataURL(type);\n\n    if (navigator.msSaveOrOpenBlob) {\n      // IE11\n      var binary = atob(dataUrl.split(',')[1]); // strip the `data:image/png;base64,` part\n\n      var array = [];\n\n      for (var i = 0, n = binary.length; i < n; i++) {\n        array.push(binary.charCodeAt(i));\n      }\n\n      var blob = new Blob([new Uint8Array(array)], {\n        type: type\n      });\n      navigator.msSaveOrOpenBlob(blob, fileName + '.png');\n    } else {\n      var a = document.createElement('a');\n      a.href = dataUrl;\n      a.download = fileName + '.png';\n      a.style.display = 'none';\n      document.body.appendChild(a); // required for the `click` to work in Firefox\n\n      a.click();\n      document.body.removeChild(a);\n    }\n  };\n\n  Object.defineProperty(HdpiCanvas.prototype, \"pixelRatio\", {\n    get: function get() {\n      return this._pixelRatio;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Updates the pixel ratio of the Canvas element with the given value,\n   * or uses the window.devicePixelRatio (default), then resizes the Canvas\n   * element accordingly (default).\n   * @param ratio\n   * @param resize\n   */\n\n  HdpiCanvas.prototype.updatePixelRatio = function (ratio, resize) {\n    if (ratio === void 0) {\n      ratio = 0;\n    }\n\n    if (resize === void 0) {\n      resize = true;\n    }\n\n    var pixelRatio = ratio || window.devicePixelRatio;\n\n    if (pixelRatio === this.pixelRatio) {\n      return;\n    }\n\n    var canvas = this.canvas;\n    var ctx = this.context;\n    var overrides = this.overrides = HdpiCanvas.makeHdpiOverrides(pixelRatio);\n\n    for (var name_1 in overrides) {\n      if (overrides.hasOwnProperty(name_1)) {\n        // Save native methods under prefixed names,\n        // if this hasn't been done by the previous overrides already.\n        if (!ctx['$' + name_1]) {\n          ctx['$' + name_1] = ctx[name_1];\n        } // Replace native methods with overrides,\n        // or previous overrides with the new ones.\n\n\n        ctx[name_1] = overrides[name_1];\n      }\n    }\n\n    if (resize) {\n      var logicalWidth = canvas.width / this.pixelRatio;\n      var logicalHeight = canvas.height / this.pixelRatio;\n      canvas.width = Math.round(logicalWidth * pixelRatio);\n      canvas.height = Math.round(logicalHeight * pixelRatio);\n      canvas.style.width = Math.round(logicalWidth) + 'px';\n      canvas.style.height = Math.round(logicalHeight) + 'px';\n      ctx.resetTransform(); // should be called every time Canvas size changes\n    }\n\n    this._pixelRatio = pixelRatio;\n  };\n\n  HdpiCanvas.prototype.resize = function (width, height) {\n    var canvas = this.canvas;\n    canvas.width = Math.round(width * this.pixelRatio);\n    canvas.height = Math.round(height * this.pixelRatio);\n    canvas.style.width = Math.round(width) + 'px';\n    canvas.style.height = Math.round(height) + 'px';\n    this.context.resetTransform();\n  };\n\n  Object.defineProperty(HdpiCanvas, \"svgText\", {\n    get: function get() {\n      if (HdpiCanvas._svgText) {\n        return HdpiCanvas._svgText;\n      }\n\n      var xmlns = 'http://www.w3.org/2000/svg';\n      var svg = document.createElementNS(xmlns, 'svg');\n      svg.setAttribute('width', '100');\n      svg.setAttribute('height', '100');\n      svg.style.position = 'absolute';\n      svg.style.top = '-1000px';\n      svg.style.visibility = 'hidden';\n      var svgText = document.createElementNS(xmlns, 'text');\n      svgText.setAttribute('x', '0');\n      svgText.setAttribute('y', '30');\n      svgText.setAttribute('text', 'black');\n      svg.appendChild(svgText);\n      document.body.appendChild(svg);\n      HdpiCanvas._svgText = svgText;\n      return svgText;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ;\n\n  HdpiCanvas.measureText = function (text, font, textBaseline, textAlign) {\n    var ctx = HdpiCanvas.textContext;\n    ctx.font = font;\n    ctx.textBaseline = textBaseline;\n    ctx.textAlign = textAlign;\n    return ctx.measureText(text);\n  };\n  /**\n   * Returns the width and height of the measured text.\n   * @param text The single-line text to measure.\n   * @param font The font shorthand string.\n   */\n\n\n  HdpiCanvas.getTextSize = function (text, font) {\n    if (HdpiCanvas.supports.textMetrics) {\n      HdpiCanvas.textContext.font = font;\n      var metrics = HdpiCanvas.textContext.measureText(text);\n      return {\n        width: metrics.width,\n        height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n      };\n    } else {\n      return HdpiCanvas.measureSvgText(text, font);\n    }\n  };\n\n  HdpiCanvas.measureSvgText = function (text, font) {\n    var cache = HdpiCanvas.textSizeCache;\n    var fontCache = cache[font]; // Note: consider not caching the size of numeric strings.\n    // For example: if (isNaN(+text)) { // skip\n\n    if (fontCache) {\n      var size_1 = fontCache[text];\n\n      if (size_1) {\n        return size_1;\n      }\n    } else {\n      cache[font] = {};\n    }\n\n    var svgText = HdpiCanvas.svgText;\n    svgText.style.font = font;\n    svgText.textContent = text; // `getBBox` returns an instance of `SVGRect` with the same `width` and `height`\n    // measurements as `DOMRect` instance returned by the `getBoundingClientRect`.\n    // But the `SVGRect` instance has half the properties of the `DOMRect`,\n    // so we use the `getBBox` method.\n\n    var bbox = svgText.getBBox();\n    var size = {\n      width: bbox.width,\n      height: bbox.height\n    };\n    cache[font][text] = size;\n    return size;\n  };\n\n  HdpiCanvas.makeHdpiOverrides = function (pixelRatio) {\n    var depth = 0;\n    return {\n      save: function save() {\n        this.$save();\n        depth++;\n      },\n      restore: function restore() {\n        if (depth > 0) {\n          this.$restore();\n          depth--;\n        }\n      },\n      resetTransform: function resetTransform() {\n        // As of Jan 8, 2019, `resetTransform` is still an \"experimental technology\",\n        // and doesn't work in IE11 and Edge 44.\n        // this.$resetTransform();\n        this.setTransform(1, 0, 0, 1, 0, 0);\n        this.scale(pixelRatio, pixelRatio);\n        this.save();\n        depth = 0; // The scale above will be impossible to restore,\n        // because we override the `ctx.restore` above and\n        // check `depth` there.\n      }\n    };\n  }; // 2D canvas context for measuring text.\n\n\n  HdpiCanvas.textContext = function () {\n    var canvas = document.createElement('canvas');\n    return canvas.getContext('2d');\n  }();\n\n  HdpiCanvas.supports = Object.freeze({\n    textMetrics: HdpiCanvas.textContext.measureText('test').actualBoundingBoxDescent !== undefined,\n    getTransform: HdpiCanvas.textContext.getTransform !== undefined\n  });\n  HdpiCanvas.textSizeCache = {};\n  return HdpiCanvas;\n}();\n\nexports.HdpiCanvas = HdpiCanvas;","map":null,"metadata":{},"sourceType":"script"}