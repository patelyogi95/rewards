{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar stackedCartesianSeries_1 = require(\"./stackedCartesianSeries\");\n\nvar group_1 = require(\"../../scene/group\");\n\nvar selection_1 = require(\"../../scene/selection\");\n\nvar rect_1 = require(\"../../scene/shape/rect\");\n\nvar text_1 = require(\"../../scene/shape/text\");\n\nvar bandScale_1 = require(\"../../scale/bandScale\");\n\nvar colors_1 = require(\"../colors\");\n\nvar color_1 = require(\"../../util/color\");\n\nvar BarSeriesNodeTag;\n\n(function (BarSeriesNodeTag) {\n  BarSeriesNodeTag[BarSeriesNodeTag[\"Bar\"] = 0] = \"Bar\";\n  BarSeriesNodeTag[BarSeriesNodeTag[\"Label\"] = 1] = \"Label\";\n})(BarSeriesNodeTag || (BarSeriesNodeTag = {}));\n\nvar BarSeries =\n/** @class */\nfunction (_super) {\n  __extends(BarSeries, _super);\n\n  function BarSeries() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._data = [];\n    _this._grouped = false;\n    /**\n     * The stroke style to use for all bars.\n     * `null` value here doesn't mean invisible stroke, as it normally would\n     * (see `Shape.strokeStyle` comments), it means derive stroke colors from fill\n     * colors by darkening them. To make the stroke appear invisible use the same\n     * color as the background of the chart (such as 'white').\n     */\n\n    _this._strokeStyle = null;\n    _this._lineWidth = 2;\n    _this._shadow = null;\n    _this._labelFont = '12px Tahoma';\n    _this._labelColor = 'black';\n    /**\n     * Vertical and horizontal label padding as an array of two numbers.\n     */\n\n    _this._labelPadding = [10, 10];\n    _this.domainX = [];\n    _this.domainY = [];\n    _this.yData = [];\n    /**\n     * Used to get the position of bars within each group.\n     */\n\n    _this.groupScale = new bandScale_1.BandScale();\n    /**\n     * The selection of Group elements, each containing a Rect (bar) and a Text (label) nodes.\n     */\n\n    _this.groupSelection = selection_1.Selection.select(_this.group).selectAll();\n    _this.colors = colors_1.default;\n    _this.strokeColors = colors_1.default.map(function (color) {\n      return color_1.Color.fromHexString(color).darker().toHexString();\n    });\n    return _this;\n  }\n\n  Object.defineProperty(BarSeries.prototype, \"chart\", {\n    get: function get() {\n      return this._chart;\n    },\n    set: function set(chart) {\n      if (this._chart !== chart) {\n        this._chart = chart;\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"data\", {\n    get: function get() {\n      return this._data;\n    },\n    set: function set(data) {\n      this._data = data;\n\n      if (this.processData()) {\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"xField\", {\n    get: function get() {\n      return this._xField;\n    },\n    set: function set(value) {\n      if (this._xField !== value) {\n        this._xField = value;\n\n        if (this.processData()) {\n          this.update();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"yFields\", {\n    get: function get() {\n      return this._yFields;\n    },\n\n    /**\n     * With a single value in the `yFields` array we get the regular bar series.\n     * With multiple values, we get the stacked bar series.\n     * If the {@link grouped} set to `true`, we get the grouped bar series.\n     * @param values\n     */\n    set: function set(values) {\n      this._yFields = values;\n      var groupScale = this.groupScale;\n      groupScale.domain = values;\n      groupScale.padding = 0.1;\n      groupScale.round = true;\n\n      if (this.processData()) {\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * If the type of series datum is declared as `any`, one can change the values of the\n   * {@link data}, {@link xField} and {@link yFields} configs on the fly, where the type\n   * of data and the fields names are completely different from ones currently in use by\n   * the series. This can lead to a situation where one sets the new {@link data},\n   * which triggers the series to fetch the fields from the datums, but the\n   * datums have no such fields. Conversely, one can set the new {@link xField} or {@link yFields}\n   * that are not present in the current {@link data}.\n   * In such cases, the {@link data}, {@link xField} and {@link yFields} configs have to be set\n   * simultaneously, as an atomic operation.\n   * @param data\n   * @param xField\n   * @param yFields\n   */\n\n  BarSeries.prototype.setDataAndFields = function (data, xField, yFields) {\n    this._xField = xField;\n    this._yFields = yFields;\n    this._data = data;\n    var groupScale = this.groupScale;\n    groupScale.domain = yFields;\n    groupScale.padding = 0.1;\n    groupScale.round = true;\n\n    if (this.processData()) {\n      this.update();\n    }\n  };\n\n  Object.defineProperty(BarSeries.prototype, \"yFieldNames\", {\n    get: function get() {\n      return this._yFieldNames;\n    },\n    set: function set(values) {\n      this._yFieldNames = values;\n      this.update();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"grouped\", {\n    get: function get() {\n      return this._grouped;\n    },\n    set: function set(value) {\n      if (this._grouped !== value) {\n        this._grouped = value;\n\n        if (this.processData()) {\n          this.update();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"strokeStyle\", {\n    get: function get() {\n      return this._strokeStyle;\n    },\n    set: function set(value) {\n      if (this._strokeStyle !== value) {\n        this._strokeStyle = value;\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"lineWidth\", {\n    get: function get() {\n      return this._lineWidth;\n    },\n    set: function set(value) {\n      if (this._lineWidth !== value) {\n        this._lineWidth = value;\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"shadow\", {\n    get: function get() {\n      return this._shadow;\n    },\n    set: function set(value) {\n      if (this._shadow !== value) {\n        this._shadow = value;\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"labelFont\", {\n    get: function get() {\n      return this._labelFont;\n    },\n    set: function set(value) {\n      if (this._labelFont !== value) {\n        this._labelFont = value;\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"labelColor\", {\n    get: function get() {\n      return this._labelColor;\n    },\n    set: function set(value) {\n      if (this._labelColor !== value) {\n        this._labelColor = value;\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BarSeries.prototype, \"labelPadding\", {\n    get: function get() {\n      return this._labelPadding;\n    },\n    set: function set(value) {\n      if (this._labelPadding !== value) {\n        this._labelPadding = value;\n        this.update();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BarSeries.prototype.processData = function () {\n    var data = this.data;\n    var xField = this.xField;\n    var yFields = this.yFields;\n\n    if (!(xField && yFields.length)) {\n      return false;\n    } // If the data is an array of rows like so:\n    //\n    // [{\n    //   xField: 'Jan',\n    //   yField1: 5,\n    //   yField2: 7,\n    //   yField3: -9,\n    // }, {\n    //   xField: 'Feb',\n    //   yField1: 10,\n    //   yField2: -15,\n    //   yField3: 20\n    // }]\n    //\n\n\n    var xData = this.domainX = data.map(function (datum) {\n      var value = datum[xField];\n\n      if (typeof value !== 'string') {\n        throw new Error(\"The \" + xField + \" value is not a string. \" + \"This error might be solved by using the 'setDataAndFields' method.\");\n      }\n\n      return value;\n    });\n    var yData = this.yData = data.map(function (datum) {\n      var values = [];\n      yFields.forEach(function (field) {\n        var value = datum[field];\n\n        if (isNaN(value)) {\n          throw new Error(\"The \" + field + \" value is not a number. \" + \"This error might be solved by using the 'setDataAndFields' method.\");\n        }\n\n        values.push(value);\n      });\n      return values;\n    }); // xData: ['Jan', 'Feb']\n    //\n    // yData: [\n    //   [5, 7, -9],\n    //   [10, -15, 20]\n    // ]\n\n    var yMin = Infinity;\n    var yMax = -Infinity;\n\n    if (this.grouped) {\n      // Find the tallest positive/negative bar in each group,\n      // then find the tallest positive/negative bar overall.\n      // The `yMin` should always be <= 0,\n      // otherwise with the `yData` like [300, 200, 100] the last bar\n      // will have zero height, because the y-axis range is [100, 300].\n      yMin = Math.min.apply(Math, yData.map(function (groupValues) {\n        return Math.min.apply(Math, [0].concat(groupValues));\n      }));\n      yMax = Math.max.apply(Math, yData.map(function (groupValues) {\n        return Math.max.apply(Math, groupValues);\n      }));\n    } else {\n      // stacked or regular\n      // Find the height of each stack in the positive and negative directions,\n      // then find the tallest stacks in both directions.\n      yMin = Math.min.apply(Math, [0].concat(yData.map(function (stackValues) {\n        var min = 0;\n        stackValues.forEach(function (value) {\n          if (value < 0) {\n            min -= value;\n          }\n        });\n        return min;\n      })));\n      yMax = Math.max.apply(Math, yData.map(function (stackValues) {\n        var max = 0;\n        stackValues.forEach(function (value) {\n          if (value > 0) {\n            max += value;\n          }\n        });\n        return max;\n      }));\n    }\n\n    if (yMin === yMax || !isFinite(yMin) || !isFinite(yMax)) {\n      yMin = 0;\n      yMax = 1; // console.warn('Zero or infinite y-range.');\n    }\n\n    this.domainX = xData;\n    this.domainY = [yMin, yMax];\n    var chart = this.chart;\n\n    if (chart) {\n      chart.updateAxes();\n    }\n\n    return true;\n  };\n\n  BarSeries.prototype.getDomainX = function () {\n    return this.domainX;\n  };\n\n  BarSeries.prototype.getDomainY = function () {\n    return this.domainY;\n  };\n\n  BarSeries.prototype.update = function () {\n    var _this = this;\n\n    var chart = this.chart;\n\n    if (!chart || chart && chart.layoutPending || !(chart.xAxis && chart.yAxis)) {\n      return;\n    }\n\n    var n = this.data.length;\n    var xAxis = chart.xAxis;\n    var yAxis = chart.yAxis;\n    var xScale = xAxis.scale;\n    var yScale = yAxis.scale;\n    var groupScale = this.groupScale;\n    var yFields = this.yFields;\n    var colors = this.colors;\n    var strokeColor = this.strokeStyle;\n    var strokeColors = this.strokeColors;\n    var grouped = this.grouped;\n    var lineWidth = this.lineWidth;\n    var labelFont = this.labelFont;\n    var labelColor = this.labelColor;\n    var labelPadding = this.labelPadding;\n    groupScale.range = [0, xScale.bandwidth];\n    var barWidth = grouped ? groupScale.bandwidth : xScale.bandwidth;\n    var barData = [];\n\n    var _loop_1 = function _loop_1(i) {\n      var category = this_1.domainX[i];\n      var values = this_1.yData[i];\n      var x = xScale.convert(category);\n      var yFieldIndex = 0;\n      values.reduce(function (prev, curr) {\n        var barX = grouped ? x + groupScale.convert(yFields[yFieldIndex]) : x;\n        var y = yScale.convert(grouped ? curr : prev + curr);\n        var bottomY = yScale.convert(grouped ? 0 : prev);\n        var labelText = _this.yFieldNames[yFieldIndex];\n        barData.push({\n          x: barX,\n          y: y,\n          width: barWidth,\n          height: bottomY - y,\n          fillStyle: colors[yFieldIndex % colors.length],\n          strokeStyle: strokeColor ? strokeColor : strokeColors[yFieldIndex % strokeColors.length],\n          lineWidth: lineWidth,\n          label: labelText ? {\n            text: labelText,\n            font: labelFont,\n            fillStyle: labelColor,\n            x: barX + barWidth / 2,\n            y: y + lineWidth / 2 + labelPadding[0]\n          } : undefined\n        });\n        yFieldIndex++;\n        return grouped ? curr : curr + prev;\n      }, 0);\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < n; i++) {\n      _loop_1(i);\n    }\n\n    var updateGroups = this.groupSelection.setData(barData);\n    updateGroups.exit.remove();\n    var enterGroups = updateGroups.enter.append(group_1.Group);\n    enterGroups.append(rect_1.Rect).each(function (rect) {\n      rect.tag = BarSeriesNodeTag.Bar;\n      rect.crisp = true;\n    });\n    enterGroups.append(text_1.Text).each(function (text) {\n      text.tag = BarSeriesNodeTag.Label;\n      text.textBaseline = 'hanging';\n      text.textAlign = 'center';\n    });\n    var groupSelection = updateGroups.merge(enterGroups);\n    groupSelection.selectByTag(BarSeriesNodeTag.Bar).each(function (rect, datum) {\n      rect.x = datum.x;\n      rect.y = datum.y;\n      rect.width = datum.width;\n      rect.height = datum.height;\n      rect.fillStyle = datum.fillStyle;\n      rect.strokeStyle = datum.strokeStyle;\n      rect.lineWidth = datum.lineWidth;\n      rect.shadow = _this.shadow;\n      rect.visible = datum.height > 0; // prevent stroke from rendering for zero height columns\n    });\n    groupSelection.selectByTag(BarSeriesNodeTag.Label).each(function (text, datum) {\n      var label = datum.label;\n\n      if (label) {\n        text.font = label.font;\n        text.text = label.text;\n        text.x = label.x;\n        text.y = label.y;\n        text.fillStyle = label.fillStyle;\n        var textBBox = text.getBBox();\n        text.visible = datum.height > textBBox.height + datum.lineWidth + labelPadding[0] * 2 && datum.width > textBBox.width + datum.lineWidth + labelPadding[1] * 2;\n      } else {\n        text.visible = false;\n      }\n    });\n    this.groupSelection = groupSelection;\n  };\n\n  return BarSeries;\n}(stackedCartesianSeries_1.StackedCartesianSeries);\n\nexports.BarSeries = BarSeries;","map":null,"metadata":{},"sourceType":"script"}