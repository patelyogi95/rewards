{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // This is the property we set on an HTMLCanvasElement to let us know we've applied\n// the resolution independent overrides to it, and what its current DPR is.\n\nvar DevicePixelRatioKey = '__DevicePixelRatio'; // TODO: use Symbol() here in the future to truly hide this property.\n\nfunction makeHdpiOverrides(dpr) {\n  var depth = 0;\n  return {\n    save: function save() {\n      this.$save();\n      depth++;\n    },\n    restore: function restore() {\n      if (depth > 0) {\n        this.$restore();\n        depth--;\n      }\n    },\n    resetTransform: function resetTransform() {\n      this.$resetTransform();\n      this.scale(dpr, dpr);\n      this.save();\n      depth = 0; // The scale above will be impossible to restore,\n      // because we override the `ctx.restore` above and\n      // check `depth` there.\n    }\n  };\n}\n/**\n * Creates an HTMLCanvasElement element with HDPI overrides applied.\n * The `width` and `height` parameters are optional and default to\n * the values defined in the W3C Recommendation:\n * https://www.w3.org/TR/html52/semantics-scripting.html#the-canvas-element\n * @param width\n * @param height\n */\n\n\nfunction createHdpiCanvas(width, height) {\n  if (width === void 0) {\n    width = 300;\n  }\n\n  if (height === void 0) {\n    height = 150;\n  }\n\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  applyHdpiOverrides(canvas);\n  return canvas;\n}\n\nexports.createHdpiCanvas = createHdpiCanvas;\n\nfunction applyHdpiOverrides(canvas) {\n  var canvasDpr = canvas[DevicePixelRatioKey];\n  var dpr = window.devicePixelRatio; // if overrides haven't been applied and actually needed\n\n  if (!canvasDpr && dpr !== 1) {\n    var overrides = makeHdpiOverrides(dpr);\n    var ctx = canvas.getContext('2d');\n    var ctxObj = ctx;\n\n    for (var name_1 in overrides) {\n      // Save native methods under prefixed names.\n      ctxObj['$' + name_1] = ctxObj[name_1]; // Pretend our overrides are native methods.\n\n      ctxObj[name_1] = overrides[name_1];\n    }\n\n    canvas[DevicePixelRatioKey] = dpr;\n    var logicalWidth = canvas.width;\n    var logicalHeight = canvas.height;\n    canvas.width = Math.round(logicalWidth * dpr);\n    canvas.height = Math.round(logicalHeight * dpr);\n    canvas.style.width = Math.round(logicalWidth) + 'px';\n    canvas.style.height = Math.round(logicalHeight) + 'px';\n    ctx.resetTransform(); // should be called every time the size changes\n\n    return dpr;\n  }\n\n  return 0;\n}\n\nexports.applyHdpiOverrides = applyHdpiOverrides;\n/**\n * Resizes the given Canvas element, taking HDPI overrides (if any) into account.\n * @param canvas\n * @param width\n * @param height\n */\n\nfunction resizeCanvas(canvas, width, height) {\n  var canvasDpr = canvas[DevicePixelRatioKey] || 1;\n  canvas.width = Math.round(width * canvasDpr);\n  canvas.height = Math.round(height * canvasDpr);\n  canvas.style.width = Math.round(width) + 'px';\n  canvas.style.height = Math.round(height) + 'px';\n  canvas.getContext('2d').resetTransform();\n}\n\nexports.resizeCanvas = resizeCanvas;\n/**\n * Returns the position offset to apply to align vertical and horizontal\n * lines to the pixel grid for crisp look.\n * @param value Typically line width is assumed. Fractional values won't be aligned.\n * @param bias If alignment is necessary, which side to prefer.\n */\n\nfunction pixelSnap(value, bias) {\n  if (bias === void 0) {\n    bias = PixelSnapBias.Positive;\n  } // If not a fractional value ...\n\n\n  return value % 1 === 0 ? bias * value % 2 / 2 : value;\n}\n\nexports.pixelSnap = pixelSnap;\nvar PixelSnapBias;\n\n(function (PixelSnapBias) {\n  PixelSnapBias[PixelSnapBias[\"Negative\"] = -1] = \"Negative\";\n  PixelSnapBias[PixelSnapBias[\"Positive\"] = 1] = \"Positive\";\n})(PixelSnapBias = exports.PixelSnapBias || (exports.PixelSnapBias = {}));","map":null,"metadata":{},"sourceType":"script"}