{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar node_1 = require(\"./node\");\n\nvar EnterNode =\n/** @class */\nfunction () {\n  function EnterNode(parent, datum) {\n    this.next = null;\n    this.scene = parent.scene;\n    this.parent = parent;\n    this.datum = datum;\n  }\n\n  EnterNode.prototype.appendChild = function (node) {\n    // This doesn't work without the `strict: true` in the `tsconfig.json`,\n    // so we must have two `if` checks below, instead of this single one.\n    // if (this.next && !Node.isNode(this.next)) {\n    //     throw new Error(`${this.next} is not a Node.`);\n    // }\n    if (this.next === null) {\n      return this.parent.insertBefore(node, null);\n    }\n\n    if (!node_1.Node.isNode(this.next)) {\n      throw new Error(this.next + \" is not a Node.\");\n    }\n\n    return this.parent.insertBefore(node, this.next);\n  };\n\n  EnterNode.prototype.insertBefore = function (node, nextNode) {\n    return this.parent.insertBefore(node, nextNode);\n  };\n\n  return EnterNode;\n}();\n\nexports.EnterNode = EnterNode;\n/**\n * G - type of the selected node(s).\n * GDatum - type of the datum of the selected node(s).\n * P - type of the parent node(s).\n * PDatum - type of the datum of the parent node(s).\n */\n\nvar Selection =\n/** @class */\nfunction () {\n  function Selection(groups, parents) {\n    this.groups = groups;\n    this.parents = parents;\n  }\n\n  Selection.select = function (node) {\n    return new Selection([[typeof node === 'function' ? node() : node]], [undefined]);\n  };\n\n  Selection.selectAll = function (nodes) {\n    return new Selection([nodes == null ? [] : nodes], [undefined]);\n  };\n  /**\n   * Creates new nodes, appends them to the nodes of this selection and returns them\n   * as a new selection. The created nodes inherit the datums and the parents of the nodes\n   * they replace.\n   * @param Class The constructor function to use to create the new nodes.\n   */\n\n\n  Selection.prototype.append = function (Class) {\n    return this.select(function (node) {\n      return node.appendChild(new Class());\n    });\n  };\n  /**\n   * Same as the {@link append}, but accepts a custom creator function with the\n   * {@link NodeSelector} signature rather than a constructor function.\n   * @param creator\n   */\n\n\n  Selection.prototype.appendFn = function (creator) {\n    return this.select(function (node, data, index, group) {\n      return node.appendChild(creator(node, data, index, group));\n    });\n  };\n  /**\n   * Runs the given selector that returns a single node for every node in each group.\n   * The original nodes are then replaced by the nodes returned by the selector\n   * and returned as a new selection.\n   * The selected nodes inherit the datums and the parents of the original nodes.\n   */\n\n\n  Selection.prototype.select = function (selector) {\n    var groups = this.groups;\n    var numGroups = groups.length;\n    var subgroups = [];\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n      var subgroup = subgroups[j] = new Array(groupSize);\n\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n\n        if (node) {\n          var subnode = selector(node, node.datum, i, group);\n\n          if (subnode) {\n            subnode.datum = node.datum;\n          }\n\n          subgroup[i] = subnode;\n        } // else this can be a group of the `enter` selection,\n        // for example, with no nodes at the i-th position,\n        // only nodes at the end of the group\n\n      }\n    }\n\n    return new Selection(subgroups, this.parents);\n  };\n  /**\n   * Same as {@link select}, but uses the given {@param Class} (constructor) as a selector.\n   * @param Class The constructor function to use to find matching nodes.\n   */\n\n\n  Selection.prototype.selectByClass = function (Class) {\n    return this.select(function (node) {\n      if (node_1.Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child instanceof Class) {\n            return child;\n          }\n        }\n      }\n    });\n  };\n\n  Selection.prototype.selectByTag = function (tag) {\n    return this.select(function (node) {\n      if (node_1.Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child.tag === tag) {\n            return child;\n          }\n        }\n      }\n    });\n  };\n\n  Selection.prototype.selectAllByClass = function (Class) {\n    return this.selectAll(function (node) {\n      var nodes = [];\n\n      if (node_1.Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child instanceof Class) {\n            nodes.push(child);\n          }\n        }\n      }\n\n      return nodes;\n    });\n  };\n\n  Selection.prototype.selectAllByTag = function (tag) {\n    return this.selectAll(function (node) {\n      var nodes = [];\n\n      if (node_1.Node.isNode(node)) {\n        var children = node.children;\n        var n = children.length;\n\n        for (var i = 0; i < n; i++) {\n          var child = children[i];\n\n          if (child.tag === tag) {\n            nodes.push(child);\n          }\n        }\n      }\n\n      return nodes;\n    });\n  };\n\n  Selection.prototype.selectNone = function () {\n    return [];\n  };\n  /**\n   * Runs the given selector that returns a group of nodes for every node in each group.\n   * The original nodes are then replaced by the groups of nodes returned by the selector\n   * and returned as a new selection. The original nodes become the parent nodes for each\n   * group in the new selection. The selected nodes do not inherit the datums of the original nodes.\n   * If called without any parameters, creates a new selection with an empty group for each\n   * node in this selection.\n   */\n\n\n  Selection.prototype.selectAll = function (selectorAll) {\n    if (!selectorAll) {\n      selectorAll = this.selectNone;\n    } // Each subgroup is populated with the selector (run on each group node) results.\n\n\n    var subgroups = []; // In the new selection that we return, subgroups become groups,\n    // and group nodes become parents.\n\n    var parents = [];\n    var groups = this.groups;\n    var groupCount = groups.length;\n\n    for (var j = 0; j < groupCount; j++) {\n      var group = groups[j];\n      var groupLength = group.length;\n\n      for (var i = 0; i < groupLength; i++) {\n        var node = group[i];\n\n        if (node) {\n          subgroups.push(selectorAll(node, node.datum, i, group));\n          parents.push(node);\n        }\n      }\n    }\n\n    return new Selection(subgroups, parents);\n  };\n  /**\n   * Runs the given callback for every node in this selection and returns this selection.\n   * @param cb\n   */\n\n\n  Selection.prototype.each = function (cb) {\n    var groups = this.groups;\n    var numGroups = groups.length;\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n\n        if (node) {\n          cb(node, node.datum, i, group);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  Selection.prototype.remove = function () {\n    return this.each(function (node) {\n      if (node_1.Node.isNode(node)) {\n        var parent_1 = node.parent;\n\n        if (parent_1) {\n          parent_1.removeChild(node);\n        }\n      }\n    });\n  };\n\n  Selection.prototype.merge = function (other) {\n    var groups0 = this.groups;\n    var groups1 = other.groups;\n    var m0 = groups0.length;\n    var m1 = groups1.length;\n    var m = Math.min(m0, m1);\n    var merges = new Array(m0);\n    var j = 0;\n\n    for (; j < m; j++) {\n      var group0 = groups0[j];\n      var group1 = groups1[j];\n      var n = group0.length;\n      var merge = merges[j] = new Array(n);\n\n      for (var i = 0; i < n; i++) {\n        var node = group0[i] || group1[i];\n        merge[i] = node || undefined;\n      }\n    }\n\n    for (; j < m0; j++) {\n      merges[j] = groups0[j];\n    }\n\n    return new Selection(merges, this.parents);\n  };\n  /**\n   * Return the first non-null element in this selection.\n   * If the selection is empty, returns null.\n   */\n\n\n  Selection.prototype.node = function () {\n    var groups = this.groups;\n    var numGroups = groups.length;\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var groupSize = group.length;\n\n      for (var i = 0; i < groupSize; i++) {\n        var node = group[i];\n\n        if (node) {\n          return node;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  Selection.prototype.attr = function (name, value) {\n    this.each(function (node) {\n      node[name] = value;\n    });\n    return this;\n  };\n\n  Selection.prototype.attrFn = function (name, value) {\n    this.each(function (node, datum, index, group) {\n      node[name] = value(node, datum, index, group);\n    });\n    return this;\n  };\n  /**\n   * Invokes the given function once, passing in this selection.\n   * Returns this selection. Facilitates method chaining.\n   * @param cb\n   */\n\n\n  Selection.prototype.call = function (cb) {\n    cb(this);\n    return this;\n  };\n\n  Object.defineProperty(Selection.prototype, \"size\", {\n    /**\n     * Returns the total number of nodes in this selection.\n     */\n    get: function get() {\n      var size = 0;\n      this.each(function () {\n        return size++;\n      });\n      return size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"data\", {\n    /**\n     * Returns the array of data for the selected elements.\n     */\n    get: function get() {\n      var data = [];\n      this.each(function (_, datum) {\n        return data.push(datum);\n      });\n      return data;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"enter\", {\n    get: function get() {\n      return new Selection(this.enterGroups ? this.enterGroups : [[]], this.parents);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Selection.prototype, \"exit\", {\n    get: function get() {\n      return new Selection(this.exitGroups ? this.exitGroups : [[]], this.parents);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Binds the given value to each selected node and returns this selection\n   * with its {@link GDatum} type changed to the type of the given value.\n   * This method doesn't compute a join and doesn't affect indexes or the enter and exit selections.\n   * This method can also be used to clear bound data.\n   * @param value\n   */\n\n  Selection.prototype.setDatum = function (value) {\n    return this.each(function (node) {\n      node.datum = value;\n    });\n  };\n\n  Object.defineProperty(Selection.prototype, \"datum\", {\n    /**\n     * Returns the bound datum for the first non-null element in the selection.\n     * This is generally useful only if you know the selection contains exactly one element.\n     */\n    get: function get() {\n      var node = this.node();\n      return node ? node.datum : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Binds the specified array of values with the selected nodes, returning a new selection\n   * that represents the _update_ selection: the nodes successfully bound to the values.\n   * Also defines the {@link enter} and {@link exit} selections on the returned selection,\n   * which can be used to add or remove the nodes to correspond to the new data.\n   * The `values` is an array of values of a particular type, or a function that returns\n   * an array of values for each group.\n   * When values are assigned to the nodes, they are stored in the {@link Node.datum} property.\n   * @param values\n   * @param key\n   */\n\n  Selection.prototype.setData = function (values, key) {\n    if (typeof values !== 'function') {\n      var data_1 = values;\n\n      values = function values() {\n        return data_1;\n      };\n    }\n\n    var groups = this.groups;\n    var parents = this.parents;\n    var numGroups = groups.length;\n    var updateGroups = new Array(numGroups);\n    var enterGroups = new Array(numGroups);\n    var exitGroups = new Array(numGroups);\n\n    for (var j = 0; j < numGroups; j++) {\n      var group = groups[j];\n      var parent_2 = parents[j];\n\n      if (!parent_2) {\n        throw new Error(\"Group #\" + j + \" has no parent: \" + group);\n      }\n\n      var groupSize = group.length;\n      var data = values(parent_2, parent_2.datum, j, parents);\n      var dataSize = data.length;\n      var enterGroup = enterGroups[j] = new Array(dataSize);\n      var updateGroup = updateGroups[j] = new Array(dataSize);\n      var exitGroup = exitGroups[j] = new Array(groupSize);\n      if (key) this.bindKey(parent_2, group, enterGroup, updateGroup, exitGroup, data, key);else this.bindIndex(parent_2, group, enterGroup, updateGroup, exitGroup, data); // Now connect the enter nodes to their following update node, such that\n      // appendChild can insert the materialized enter node before this node,\n      // rather than at the end of the parent node.\n\n      for (var i0 = 0, i1 = 0; i0 < dataSize; i0++) {\n        var previous = enterGroup[i0];\n\n        if (previous) {\n          if (i0 >= i1) {\n            i1 = i0 + 1;\n          }\n\n          var next = void 0;\n\n          while (!(next = updateGroup[i1]) && ++i1 < dataSize) {\n            ;\n          }\n\n          previous.next = next || null;\n        }\n      }\n    }\n\n    var result = new Selection(updateGroups, parents);\n    result.enterGroups = enterGroups;\n    result.exitGroups = exitGroups;\n    return result;\n  };\n\n  Selection.prototype.bindIndex = function (parent, group, enter, update, exit, data) {\n    var groupSize = group.length;\n    var dataSize = data.length;\n    var i = 0;\n\n    for (; i < dataSize; i++) {\n      var node = group[i];\n\n      if (node) {\n        node.datum = data[i];\n        update[i] = node;\n      } else {\n        // more datums than group nodes\n        enter[i] = new EnterNode(parent, data[i]);\n      }\n    } // more group nodes than datums\n\n\n    for (; i < groupSize; i++) {\n      var node = group[i];\n\n      if (node) {\n        exit[i] = node;\n      }\n    }\n  };\n\n  Selection.prototype.bindKey = function (parent, group, enter, update, exit, data, key) {\n    var groupSize = group.length;\n    var dataSize = data.length;\n    var keyValues = new Array(groupSize);\n    var nodeByKeyValue = {}; // Compute the key for each node.\n    // If multiple nodes have the same key, the duplicates are added to exit.\n\n    for (var i = 0; i < groupSize; i++) {\n      var node = group[i];\n\n      if (node) {\n        var keyValue = keyValues[i] = Selection.keyPrefix + key(node, node.datum, i, group);\n\n        if (keyValue in nodeByKeyValue) {\n          exit[i] = node;\n        } else {\n          nodeByKeyValue[keyValue] = node;\n        }\n      }\n    } // Compute the key for each datum.\n    // If there is a node associated with this key, join and add it to update.\n    // If there is not (or the key is a duplicate), add it to enter.\n\n\n    for (var i = 0; i < dataSize; i++) {\n      var keyValue = Selection.keyPrefix + key(parent, data[i], i, data);\n      var node = nodeByKeyValue[keyValue];\n\n      if (node) {\n        update[i] = node;\n        node.datum = data[i];\n        nodeByKeyValue[keyValue] = undefined;\n      } else {\n        enter[i] = new EnterNode(parent, data[i]);\n      }\n    } // Add any remaining nodes that were not bound to data to exit.\n\n\n    for (var i = 0; i < groupSize; i++) {\n      var node = group[i];\n\n      if (node && nodeByKeyValue[keyValues[i]] === node) {\n        exit[i] = node;\n      }\n    }\n  };\n\n  Selection.keyPrefix = '$'; // Protect against keys like '__proto__'.\n\n  return Selection;\n}();\n\nexports.Selection = Selection;","map":null,"metadata":{},"sourceType":"script"}