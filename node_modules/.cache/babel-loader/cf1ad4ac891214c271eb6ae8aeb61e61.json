{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar serverSideCache_1 = require(\"./serverSideCache\");\n\nvar serverSideBlock_1 = require(\"./serverSideBlock\");\n\nvar ServerSideRowModel =\n/** @class */\nfunction (_super) {\n  __extends(ServerSideRowModel, _super);\n\n  function ServerSideRowModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // we don't implement as lazy row heights is not supported in this row model\n\n\n  ServerSideRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) {\n    return false;\n  };\n\n  ServerSideRowModel.prototype.postConstruct = function () {\n    this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n    this.addEventListeners();\n    var datasource = this.gridOptionsWrapper.getServerSideDatasource();\n\n    if (ag_grid_community_1._.exists(datasource)) {\n      this.setDatasource(datasource);\n    }\n  };\n\n  ServerSideRowModel.prototype.destroyDatasource = function () {\n    if (this.datasource) {\n      if (this.datasource.destroy) {\n        this.datasource.destroy();\n      }\n\n      this.rowRenderer.datasourceChanged();\n      this.datasource = undefined;\n    }\n  };\n\n  ServerSideRowModel.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ServerSideRowModel');\n  };\n\n  ServerSideRowModel.prototype.addEventListeners = function () {\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onColumnEverything.bind(this));\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, ag_grid_community_1.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n  };\n\n  ServerSideRowModel.prototype.setDatasource = function (datasource) {\n    this.destroyDatasource();\n    this.datasource = datasource;\n    this.reset();\n  };\n\n  ServerSideRowModel.prototype.isLastRowFound = function () {\n    if (this.cacheExists()) {\n      return this.rootNode.childrenCache.isMaxRowFound();\n    } else {\n      return false;\n    }\n  };\n\n  ServerSideRowModel.prototype.onColumnEverything = function () {\n    // this is a hack for one customer only, so they can suppress the resetting of the columns.\n    // The problem the customer had was they were api.setColumnDefs() after the data source came\n    // back with data. So this stops the reload from the grid after the data comes back.\n    // Once we have \"AG-1591 Allow delta changes to columns\" fixed, then this hack can be taken out.\n    if (this.gridOptionsWrapper.isSuppressEnterpriseResetOnNewColumns()) {\n      return;\n    } // every other customer can continue as normal and have it working!!!\n    // check if anything pertaining to fetching data has changed, and if it has, reset, but if\n    // it has not, don't reset\n\n\n    var resetRequired;\n\n    if (!this.cacheParams) {\n      resetRequired = true;\n    } else {\n      var rowGroupColumnVos = this.toValueObjects(this.columnController.getRowGroupColumns());\n      var valueColumnVos = this.toValueObjects(this.columnController.getValueColumns());\n      var pivotColumnVos = this.toValueObjects(this.columnController.getPivotColumns());\n      var sortModelDifferent = !ag_grid_community_1._.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());\n      var rowGroupDifferent = !ag_grid_community_1._.jsonEquals(this.cacheParams.rowGroupCols, rowGroupColumnVos);\n      var pivotDifferent = !ag_grid_community_1._.jsonEquals(this.cacheParams.pivotCols, pivotColumnVos);\n      var valuesDifferent = !ag_grid_community_1._.jsonEquals(this.cacheParams.valueCols, valueColumnVos);\n      resetRequired = sortModelDifferent || rowGroupDifferent || pivotDifferent || valuesDifferent;\n    }\n\n    if (resetRequired) {\n      this.reset();\n    }\n  };\n\n  ServerSideRowModel.prototype.onFilterChanged = function () {\n    this.reset();\n  }; // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,\n  // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache\n  // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache\n  // was previously sorted by A and then the A sort now needs to be cleared.\n\n\n  ServerSideRowModel.prototype.findChangedColumnsInSort = function (newSortModel, oldSortModel) {\n    var allColsInBothSorts = [];\n    [newSortModel, oldSortModel].forEach(function (sortModel) {\n      if (sortModel) {\n        var ids = sortModel.map(function (sm) {\n          return sm.colId;\n        });\n        allColsInBothSorts = allColsInBothSorts.concat(ids);\n      }\n    });\n\n    var differentSorts = function differentSorts(oldSortItem, newSortItem) {\n      var oldSort = oldSortItem ? oldSortItem.sort : null;\n      var newSort = newSortItem ? newSortItem.sort : null;\n      return oldSort !== newSort;\n    };\n\n    var differentIndexes = function differentIndexes(oldSortItem, newSortItem) {\n      var oldIndex = oldSortModel.indexOf(oldSortItem);\n      var newIndex = newSortModel.indexOf(newSortItem);\n      return oldIndex !== newIndex;\n    };\n\n    return allColsInBothSorts.filter(function (colId) {\n      var oldSortItem = ag_grid_community_1._.find(oldSortModel, function (sm) {\n        return sm.colId === colId;\n      });\n\n      var newSortItem = ag_grid_community_1._.find(newSortModel, function (sm) {\n        return sm.colId === colId;\n      });\n\n      return differentSorts(oldSortItem, newSortItem) || differentIndexes(oldSortItem, newSortItem);\n    });\n  };\n\n  ServerSideRowModel.prototype.onSortChanged = function () {\n    if (!this.cacheExists()) {\n      return;\n    }\n\n    var newSortModel = this.extractSortModel();\n    var oldSortModel = this.cacheParams.sortModel;\n    var changedColumnsInSort = this.findChangedColumnsInSort(newSortModel, oldSortModel);\n    this.cacheParams.sortModel = newSortModel;\n    var rowGroupColIds = this.columnController.getRowGroupColumns().map(function (col) {\n      return col.getId();\n    });\n    var serverSideCache = this.rootNode.childrenCache;\n    var sortingWithValueCol = this.isSortingWithValueColumn(changedColumnsInSort);\n    var sortingWithSecondaryCol = this.isSortingWithSecondaryColumn(changedColumnsInSort);\n    var sortAlwaysResets = this.gridOptionsWrapper.isServerSideSortingAlwaysResets();\n\n    if (sortAlwaysResets || sortingWithValueCol || sortingWithSecondaryCol) {\n      this.reset();\n    } else {\n      serverSideCache.refreshCacheAfterSort(changedColumnsInSort, rowGroupColIds);\n    }\n  };\n\n  ServerSideRowModel.prototype.onValueChanged = function () {\n    this.reset();\n  };\n\n  ServerSideRowModel.prototype.onColumnRowGroupChanged = function () {\n    this.reset();\n  };\n\n  ServerSideRowModel.prototype.onColumnPivotChanged = function () {\n    this.reset();\n  };\n\n  ServerSideRowModel.prototype.onPivotModeChanged = function () {\n    this.reset();\n  };\n\n  ServerSideRowModel.prototype.onRowGroupOpened = function (event) {\n    var _this = this;\n\n    var rowNode = event.node;\n\n    if (rowNode.expanded) {\n      if (rowNode.master) {\n        this.createDetailNode(rowNode);\n      } else if (ag_grid_community_1._.missing(rowNode.childrenCache)) {\n        this.createNodeCache(rowNode);\n      }\n    } else {\n      if (this.gridOptionsWrapper.isPurgeClosedRowNodes() && ag_grid_community_1._.exists(rowNode.childrenCache)) {\n        rowNode.childrenCache.destroy();\n        rowNode.childrenCache = null;\n      }\n    }\n\n    var shouldAnimate = function shouldAnimate() {\n      var rowAnimationEnabled = _this.gridOptionsWrapper.isAnimateRows();\n\n      if (rowNode.master) return rowAnimationEnabled && rowNode.expanded;\n      return rowAnimationEnabled;\n    };\n\n    this.updateRowIndexesAndBounds();\n    var modelUpdatedEvent = {\n      type: ag_grid_community_1.Events.EVENT_MODEL_UPDATED,\n      api: this.gridOptionsWrapper.getApi(),\n      columnApi: this.gridOptionsWrapper.getColumnApi(),\n      newPage: false,\n      newData: false,\n      animate: shouldAnimate(),\n      keepRenderedRows: true\n    };\n    this.eventService.dispatchEvent(modelUpdatedEvent);\n  };\n\n  ServerSideRowModel.prototype.reset = function () {\n    this.rootNode = new ag_grid_community_1.RowNode();\n    this.rootNode.group = true;\n    this.rootNode.level = -1;\n    this.getContext().wireBean(this.rootNode);\n\n    if (this.datasource) {\n      this.createNewRowNodeBlockLoader();\n      this.cacheParams = this.createCacheParams();\n      this.createNodeCache(this.rootNode);\n      this.updateRowIndexesAndBounds();\n    } // this event: 1) clears selection 2) updates filters 3) shows/hides 'no rows' overlay\n\n\n    var rowDataChangedEvent = {\n      type: ag_grid_community_1.Events.EVENT_ROW_DATA_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(rowDataChangedEvent); // this gets the row to render rows (or remove the previously rendered rows, as it's blank to start).\n    // important to NOT pass in an event with keepRenderedRows or animate, as we want the renderer\n    // to treat the rows as new rows, as it's all new data\n\n    var modelUpdatedEvent = {\n      type: ag_grid_community_1.Events.EVENT_MODEL_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      animate: false,\n      keepRenderedRows: false,\n      newData: false,\n      newPage: false\n    };\n    this.eventService.dispatchEvent(modelUpdatedEvent);\n  };\n\n  ServerSideRowModel.prototype.createNewRowNodeBlockLoader = function () {\n    this.destroyRowNodeBlockLoader();\n    var maxConcurrentRequests = this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests();\n    var blockLoadDebounceMillis = this.gridOptionsWrapper.getBlockLoadDebounceMillis();\n    this.rowNodeBlockLoader = new ag_grid_community_1.RowNodeBlockLoader(maxConcurrentRequests, blockLoadDebounceMillis);\n    this.getContext().wireBean(this.rowNodeBlockLoader);\n  };\n\n  ServerSideRowModel.prototype.destroyRowNodeBlockLoader = function () {\n    if (this.rowNodeBlockLoader) {\n      this.rowNodeBlockLoader.destroy();\n      this.rowNodeBlockLoader = undefined;\n    }\n  };\n\n  ServerSideRowModel.prototype.toValueObjects = function (columns) {\n    var _this = this;\n\n    return columns.map(function (col) {\n      return {\n        id: col.getId(),\n        aggFunc: col.getAggFunc(),\n        displayName: _this.columnController.getDisplayNameForColumn(col, 'model'),\n        field: col.getColDef().field\n      };\n    });\n  };\n\n  ServerSideRowModel.prototype.createCacheParams = function () {\n    var rowGroupColumnVos = this.toValueObjects(this.columnController.getRowGroupColumns());\n    var valueColumnVos = this.toValueObjects(this.columnController.getValueColumns());\n    var pivotColumnVos = this.toValueObjects(this.columnController.getPivotColumns());\n    var dynamicRowHeight = this.gridOptionsWrapper.isDynamicRowHeight();\n    var maxBlocksInCache = this.gridOptionsWrapper.getMaxBlocksInCache();\n\n    if (dynamicRowHeight && maxBlocksInCache >= 0) {\n      console.warn('ag-Grid: Server Side Row Model does not support Dynamic Row Height and Cache Purging. ' + 'Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.');\n      maxBlocksInCache = undefined;\n    }\n\n    if (maxBlocksInCache >= 0 && this.columnController.isAutoRowHeightActive()) {\n      console.warn('ag-Grid: Server Side Row Model does not support Auto Row Height and Cache Purging. ' + 'Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.');\n      maxBlocksInCache = undefined;\n    }\n\n    var params = {\n      // the columns the user has grouped and aggregated by\n      valueCols: valueColumnVos,\n      rowGroupCols: rowGroupColumnVos,\n      pivotCols: pivotColumnVos,\n      pivotMode: this.columnController.isPivotMode(),\n      // sort and filter model\n      filterModel: this.filterManager.getFilterModel(),\n      sortModel: this.extractSortModel(),\n      rowNodeBlockLoader: this.rowNodeBlockLoader,\n      datasource: this.datasource,\n      lastAccessedSequence: new ag_grid_community_1.NumberSequence(),\n      overflowSize: 1,\n      initialRowCount: 1,\n      maxConcurrentRequests: this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests() || 0,\n      maxBlocksInCache: maxBlocksInCache,\n      blockSize: this.gridOptionsWrapper.getCacheBlockSize(),\n      rowHeight: this.rowHeight,\n      dynamicRowHeight: dynamicRowHeight\n    }; // set defaults\n\n    if (!(params.maxConcurrentRequests >= 1)) {\n      params.maxConcurrentRequests = 2;\n    } // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the\n    // server for one page at a time. so the default if not specified is 100.\n\n\n    if (!(params.blockSize >= 1)) {\n      params.blockSize = serverSideBlock_1.ServerSideBlock.DefaultBlockSize;\n    } // if user doesn't give initial rows to display, we assume zero\n\n\n    if (!(params.initialRowCount >= 1)) {\n      params.initialRowCount = 0;\n    } // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past\n    // the current page and request first row of next page\n\n\n    if (!(params.overflowSize >= 1)) {\n      params.overflowSize = 1;\n    }\n\n    return params;\n  };\n\n  ServerSideRowModel.prototype.createNodeCache = function (rowNode) {\n    var cache = new serverSideCache_1.ServerSideCache(this.cacheParams, rowNode);\n    this.getContext().wireBean(cache);\n    cache.addEventListener(ag_grid_community_1.RowNodeCache.EVENT_CACHE_UPDATED, this.onCacheUpdated.bind(this));\n    rowNode.childrenCache = cache;\n  };\n\n  ServerSideRowModel.prototype.onCacheUpdated = function () {\n    this.updateRowIndexesAndBounds();\n    var modelUpdatedEvent = {\n      type: ag_grid_community_1.Events.EVENT_MODEL_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      animate: this.gridOptionsWrapper.isAnimateRows(),\n      keepRenderedRows: true,\n      newPage: false,\n      newData: false\n    };\n    this.eventService.dispatchEvent(modelUpdatedEvent);\n  };\n\n  ServerSideRowModel.prototype.updateRowIndexesAndBounds = function () {\n    if (this.cacheExists()) {\n      // NOTE: should not be casting here, the RowModel should use IServerSideRowModel interface?\n      var serverSideCache = this.rootNode.childrenCache;\n      this.resetRowTops(serverSideCache);\n      this.setDisplayIndexes(serverSideCache);\n    }\n  };\n\n  ServerSideRowModel.prototype.setDisplayIndexes = function (cache) {\n    var numberSequence = new ag_grid_community_1.NumberSequence();\n    var nextRowTop = {\n      value: 0\n    };\n    cache.setDisplayIndexes(numberSequence, nextRowTop);\n  }; // resetting row tops is needed for animation, as part of the operation is saving the old location,\n  // which is needed for rows that are transitioning in\n\n\n  ServerSideRowModel.prototype.resetRowTops = function (cache) {\n    var numberSequence = new ag_grid_community_1.NumberSequence();\n    cache.forEachNodeDeep(function (rowNode) {\n      return rowNode.clearRowTop();\n    }, numberSequence);\n  };\n\n  ServerSideRowModel.prototype.getRow = function (index) {\n    if (this.cacheExists()) {\n      return this.rootNode.childrenCache.getRow(index);\n    }\n\n    return null;\n  };\n\n  ServerSideRowModel.prototype.getPageFirstRow = function () {\n    return 0;\n  };\n\n  ServerSideRowModel.prototype.getPageLastRow = function () {\n    var lastRow;\n\n    if (this.cacheExists()) {\n      // NOTE: should not be casting here, the RowModel should use IServerSideRowModel interface?\n      var serverSideCache = this.rootNode.childrenCache;\n      lastRow = serverSideCache.getDisplayIndexEnd() - 1;\n    } else {\n      lastRow = 0;\n    }\n\n    return lastRow;\n  };\n\n  ServerSideRowModel.prototype.getRowCount = function () {\n    return this.getPageLastRow() + 1;\n  };\n\n  ServerSideRowModel.prototype.getRowBounds = function (index) {\n    if (!this.cacheExists()) {\n      return {\n        rowTop: 0,\n        rowHeight: this.rowHeight\n      };\n    }\n\n    var serverSideCache = this.rootNode.childrenCache;\n    return serverSideCache.getRowBounds(index);\n  };\n\n  ServerSideRowModel.prototype.getRowIndexAtPixel = function (pixel) {\n    if (pixel === 0) {\n      return 0;\n    }\n\n    if (!this.cacheExists()) {\n      return 0;\n    }\n\n    var serverSideCache = this.rootNode.childrenCache;\n    return serverSideCache.getRowIndexAtPixel(pixel);\n  };\n\n  ServerSideRowModel.prototype.getCurrentPageHeight = function () {\n    return this.rowHeight * this.getRowCount();\n  };\n\n  ServerSideRowModel.prototype.isEmpty = function () {\n    return false;\n  };\n\n  ServerSideRowModel.prototype.isRowsToRender = function () {\n    return this.cacheExists() && this.getRowCount() > 0;\n  };\n\n  ServerSideRowModel.prototype.getType = function () {\n    return ag_grid_community_1.Constants.ROW_MODEL_TYPE_SERVER_SIDE;\n  };\n\n  ServerSideRowModel.prototype.forEachNode = function (callback) {\n    if (this.cacheExists()) {\n      this.rootNode.childrenCache.forEachNodeDeep(callback, new ag_grid_community_1.NumberSequence());\n    }\n  };\n\n  ServerSideRowModel.prototype.executeOnCache = function (route, callback) {\n    if (this.cacheExists()) {\n      var topLevelCache = this.rootNode.childrenCache;\n      var cacheToPurge = topLevelCache.getChildCache(route);\n\n      if (cacheToPurge) {\n        callback(cacheToPurge);\n      }\n    }\n  };\n\n  ServerSideRowModel.prototype.purgeCache = function (route) {\n    if (route === void 0) {\n      route = [];\n    }\n\n    this.executeOnCache(route, function (cache) {\n      return cache.purgeCache();\n    });\n  };\n\n  ServerSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n    if (ag_grid_community_1._.exists(firstInRange) && firstInRange.parent !== lastInRange.parent) {\n      return [];\n    }\n\n    return lastInRange.parent.childrenCache.getRowNodesInRange(firstInRange, lastInRange);\n  };\n\n  ServerSideRowModel.prototype.getRowNode = function (id) {\n    var result = null;\n    this.forEachNode(function (rowNode) {\n      if (rowNode.id === id) {\n        result = rowNode;\n      }\n    });\n    return result;\n  };\n\n  ServerSideRowModel.prototype.getBlockState = function () {\n    if (this.rowNodeBlockLoader) {\n      return this.rowNodeBlockLoader.getBlockState();\n    } else {\n      return null;\n    }\n  }; // always returns true - this is used by the\n\n\n  ServerSideRowModel.prototype.isRowPresent = function (rowNode) {\n    var foundRowNode = this.getRowNode(rowNode.id);\n    return !!foundRowNode;\n  };\n\n  ServerSideRowModel.prototype.extractSortModel = function () {\n    var sortModel = this.sortController.getSortModel(); // when using tree data we just return the sort model with the 'ag-Grid-AutoColumn' as is, i.e not broken out\n    // into it's constitute group columns as they are not defined up front and can vary per node.\n\n    if (this.gridOptionsWrapper.isTreeData()) {\n      return sortModel;\n    }\n\n    var rowGroupCols = this.toValueObjects(this.columnController.getRowGroupColumns()); // find index of auto group column in sort model\n\n    var autoGroupIndex = -1;\n\n    for (var i = 0; i < sortModel.length; ++i) {\n      if (sortModel[i].colId === ag_grid_community_1.Constants.GROUP_AUTO_COLUMN_ID) {\n        autoGroupIndex = i;\n        break;\n      }\n    } // replace auto column with individual group columns\n\n\n    if (autoGroupIndex > -1) {\n      var individualGroupCols = rowGroupCols.map(function (group) {\n        return {\n          colId: group.field,\n          sort: sortModel[autoGroupIndex].sort\n        };\n      }); // remove auto group column\n\n      sortModel.splice(autoGroupIndex, 1);\n\n      var _loop_1 = function _loop_1(i) {\n        var individualGroupCol = individualGroupCols[i]; // don't add individual group column if non group column already exists as it gets precedence\n\n        var sameNonGroupColumnExists = sortModel.some(function (sm) {\n          return sm.colId === individualGroupCol.colId;\n        });\n\n        if (sameNonGroupColumnExists) {\n          return \"continue\";\n        }\n\n        sortModel.splice(autoGroupIndex++, 0, individualGroupCol);\n      }; // insert individual group columns\n\n\n      for (var i = 0; i < individualGroupCols.length; i++) {\n        _loop_1(i);\n      }\n    } // strip out multi-column prefix on colId's\n\n\n    if (this.gridOptionsWrapper.isGroupMultiAutoColumn()) {\n      var multiColumnPrefix = ag_grid_community_1.Constants.GROUP_AUTO_COLUMN_ID + \"-\";\n\n      for (var i = 0; i < sortModel.length; ++i) {\n        if (sortModel[i].colId.indexOf(multiColumnPrefix) > -1) {\n          sortModel[i].colId = sortModel[i].colId.substr(multiColumnPrefix.length);\n        }\n      }\n    }\n\n    return sortModel;\n  };\n\n  ServerSideRowModel.prototype.isSortingWithValueColumn = function (changedColumnsInSort) {\n    var valueColIds = this.columnController.getValueColumns().map(function (col) {\n      return col.getColId();\n    });\n\n    for (var i = 0; i < changedColumnsInSort.length; i++) {\n      if (valueColIds.indexOf(changedColumnsInSort[i]) > -1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  ServerSideRowModel.prototype.isSortingWithSecondaryColumn = function (changedColumnsInSort) {\n    if (!this.columnController.getSecondaryColumns()) {\n      return false;\n    }\n\n    var secondaryColIds = this.columnController.getSecondaryColumns().map(function (col) {\n      return col.getColId();\n    });\n\n    for (var i = 0; i < changedColumnsInSort.length; i++) {\n      if (secondaryColIds.indexOf(changedColumnsInSort[i]) > -1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  ServerSideRowModel.prototype.cacheExists = function () {\n    return ag_grid_community_1._.exists(this.rootNode) && ag_grid_community_1._.exists(this.rootNode.childrenCache);\n  };\n\n  ServerSideRowModel.prototype.createDetailNode = function (masterNode) {\n    if (ag_grid_community_1._.exists(masterNode.detailNode)) {\n      return masterNode.detailNode;\n    } else {\n      var detailNode = new ag_grid_community_1.RowNode();\n      this.getContext().wireBean(detailNode);\n      detailNode.detail = true;\n      detailNode.selectable = false;\n      detailNode.parent = masterNode;\n\n      if (ag_grid_community_1._.exists(masterNode.id)) {\n        detailNode.id = 'detail_' + masterNode.id;\n      }\n\n      detailNode.data = masterNode.data;\n      detailNode.level = masterNode.level + 1;\n      var defaultDetailRowHeight = 200;\n      var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(detailNode).height;\n      detailNode.rowHeight = rowHeight ? rowHeight : defaultDetailRowHeight;\n      masterNode.detailNode = detailNode;\n      return detailNode;\n    }\n  };\n\n  __decorate([ag_grid_community_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)], ServerSideRowModel.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('eventService'), __metadata(\"design:type\", ag_grid_community_1.EventService)], ServerSideRowModel.prototype, \"eventService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnController'), __metadata(\"design:type\", ag_grid_community_1.ColumnController)], ServerSideRowModel.prototype, \"columnController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('filterManager'), __metadata(\"design:type\", ag_grid_community_1.FilterManager)], ServerSideRowModel.prototype, \"filterManager\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('sortController'), __metadata(\"design:type\", ag_grid_community_1.SortController)], ServerSideRowModel.prototype, \"sortController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridApi'), __metadata(\"design:type\", ag_grid_community_1.GridApi)], ServerSideRowModel.prototype, \"gridApi\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnApi'), __metadata(\"design:type\", ag_grid_community_1.ColumnApi)], ServerSideRowModel.prototype, \"columnApi\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rowRenderer'), __metadata(\"design:type\", ag_grid_community_1.RowRenderer)], ServerSideRowModel.prototype, \"rowRenderer\", void 0);\n\n  __decorate([ag_grid_community_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], ServerSideRowModel.prototype, \"postConstruct\", null);\n\n  __decorate([ag_grid_community_1.PreDestroy, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], ServerSideRowModel.prototype, \"destroyDatasource\", null);\n\n  __decorate([__param(0, ag_grid_community_1.Qualifier('loggerFactory')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [ag_grid_community_1.LoggerFactory]), __metadata(\"design:returntype\", void 0)], ServerSideRowModel.prototype, \"setBeans\", null);\n\n  ServerSideRowModel = __decorate([ag_grid_community_1.Bean('rowModel')], ServerSideRowModel);\n  return ServerSideRowModel;\n}(ag_grid_community_1.BeanStub);\n\nexports.ServerSideRowModel = ServerSideRowModel;","map":null,"metadata":{},"sourceType":"script"}