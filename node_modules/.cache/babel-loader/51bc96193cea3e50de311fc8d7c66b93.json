{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar shape_1 = require(\"./shape\");\n\nvar object_1 = require(\"../../util/object\");\n\nvar canvas_1 = require(\"../../canvas/canvas\");\n\nvar Line =\n/** @class */\nfunction (_super) {\n  __extends(Line, _super);\n\n  function Line() {\n    var _this = _super.call(this) || this;\n\n    _this._x1 = 0;\n    _this._y1 = 0;\n    _this._x2 = 0;\n    _this._y2 = 0;\n    _this.getBBox = undefined;\n    _this._pixelSnapBias = canvas_1.PixelSnapBias.Positive;\n\n    _this.restoreOwnStyles();\n\n    return _this;\n  }\n\n  Line.create = function (x1, y1, x2, y2) {\n    var line = new Line();\n    line.x1 = x1;\n    line.y1 = y1;\n    line.x2 = x2;\n    line.y2 = y2;\n    return line;\n  };\n\n  Object.defineProperty(Line.prototype, \"x1\", {\n    get: function get() {\n      // TODO: Investigate getter performance further in the context\n      //       of the scene graph.\n      //       In isolated benchmarks using a getter has the same\n      //       performance as a direct property access in Firefox 64.\n      //       But in Chrome 71 the getter is 60% slower than direct access.\n      //       Direct read is 4.5+ times slower in Chrome than it is in Firefox.\n      //       Property access and direct read have the same performance\n      //       in Safari 12, which is 2+ times faster than Firefox at this.\n      // https://jsperf.com/es5-getters-setters-versus-getter-setter-methods/18\n      // This is a know Chrome issue. They say it's not a regression, since\n      // the behavior is observed since M60, but jsperf.com history shows the\n      // 10x slowdown happened between Chrome 48 and Chrome 57.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=908743\n      return this._x1;\n    },\n    set: function set(value) {\n      if (this._x1 !== value) {\n        this._x1 = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Line.prototype, \"y1\", {\n    get: function get() {\n      return this._y1;\n    },\n    set: function set(value) {\n      if (this._y1 !== value) {\n        this._y1 = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Line.prototype, \"x2\", {\n    get: function get() {\n      return this._x2;\n    },\n    set: function set(value) {\n      if (this._x2 !== value) {\n        this._x2 = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Line.prototype, \"y2\", {\n    get: function get() {\n      return this._y2;\n    },\n    set: function set(value) {\n      if (this._y2 !== value) {\n        this._y2 = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Line.prototype, \"pixelSnapBias\", {\n    get: function get() {\n      return this._pixelSnapBias;\n    },\n    set: function set(value) {\n      if (this._pixelSnapBias !== value) {\n        this._pixelSnapBias = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Line.prototype.isPointInPath = function (x, y) {\n    return false;\n  };\n\n  Line.prototype.isPointInStroke = function (x, y) {\n    return false;\n  };\n\n  Line.prototype.render = function (ctx) {\n    if (this.dirtyTransform) {\n      this.computeTransformMatrix();\n    }\n\n    this.matrix.toContext(ctx);\n    this.applyContextAttributes(ctx);\n    var x1 = this.x1;\n    var y1 = this.y1;\n    var x2 = this.x2;\n    var y2 = this.y2; // Align to the pixel grid if the line is strictly vertical\n    // or horizontal (but not both, i.e. a dot).\n\n    if (x1 === x2) {\n      var delta = canvas_1.pixelSnap(this.lineWidth, this.pixelSnapBias);\n      x1 += delta;\n      x2 += delta;\n    } else if (y1 === y2) {\n      var delta = canvas_1.pixelSnap(this.lineWidth, this.pixelSnapBias);\n      y1 += delta;\n      y2 += delta;\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n\n    if (this.strokeStyle) {\n      ctx.stroke();\n    }\n\n    this.dirty = false;\n  };\n\n  Line.defaultStyles = object_1.chainObjects(shape_1.Shape.defaultStyles, {\n    lineWidth: 1\n  });\n  return Line;\n}(shape_1.Shape);\n\nexports.Line = Line;","map":null,"metadata":{},"sourceType":"script"}