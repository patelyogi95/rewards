{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar AggFuncService =\n/** @class */\nfunction () {\n  function AggFuncService() {\n    this.aggFuncsMap = {};\n    this.initialised = false;\n  }\n\n  AggFuncService_1 = AggFuncService;\n\n  AggFuncService.prototype.init = function () {\n    if (this.initialised) {\n      return;\n    }\n\n    this.initialised = true;\n    this.initialiseWithDefaultAggregations();\n    this.addAggFuncs(this.gridOptionsWrapper.getAggFuncs());\n  };\n\n  AggFuncService.prototype.initialiseWithDefaultAggregations = function () {\n    this.aggFuncsMap[AggFuncService_1.AGG_SUM] = aggSum;\n    this.aggFuncsMap[AggFuncService_1.AGG_FIRST] = aggFirst;\n    this.aggFuncsMap[AggFuncService_1.AGG_LAST] = aggLast;\n    this.aggFuncsMap[AggFuncService_1.AGG_MIN] = aggMin;\n    this.aggFuncsMap[AggFuncService_1.AGG_MAX] = aggMax;\n    this.aggFuncsMap[AggFuncService_1.AGG_COUNT] = aggCount;\n    this.aggFuncsMap[AggFuncService_1.AGG_AVG] = aggAvg;\n  };\n\n  AggFuncService.prototype.getDefaultAggFunc = function (column) {\n    var allKeys = this.getFuncNames(column); // use 'sum' if it's a) allowed for the column and b) still registered\n    // (ie not removed by user)\n\n    var sumInKeysList = allKeys.indexOf(AggFuncService_1.AGG_SUM) >= 0;\n\n    var sumInFuncs = ag_grid_community_1._.exists(this.aggFuncsMap[AggFuncService_1.AGG_SUM]);\n\n    var useSum = sumInKeysList && sumInFuncs;\n\n    if (useSum) {\n      return AggFuncService_1.AGG_SUM;\n    } else {\n      if (ag_grid_community_1._.existsAndNotEmpty(allKeys)) {\n        return allKeys[0];\n      } else {\n        return null;\n      }\n    }\n  };\n\n  AggFuncService.prototype.addAggFuncs = function (aggFuncs) {\n    ag_grid_community_1._.iterateObject(aggFuncs, this.addAggFunc.bind(this));\n  };\n\n  AggFuncService.prototype.addAggFunc = function (key, aggFunc) {\n    this.init();\n    this.aggFuncsMap[key] = aggFunc;\n  };\n\n  AggFuncService.prototype.getAggFunc = function (name) {\n    this.init();\n    return this.aggFuncsMap[name];\n  };\n\n  AggFuncService.prototype.getFuncNames = function (column) {\n    var userAllowedFuncs = column.getColDef().allowedAggFuncs;\n\n    if (ag_grid_community_1._.exists(userAllowedFuncs) && userAllowedFuncs) {\n      return userAllowedFuncs;\n    } else {\n      return Object.keys(this.aggFuncsMap).sort();\n    }\n  };\n\n  AggFuncService.prototype.clear = function () {\n    this.aggFuncsMap = {};\n  };\n\n  var AggFuncService_1;\n  AggFuncService.AGG_SUM = 'sum';\n  AggFuncService.AGG_FIRST = 'first';\n  AggFuncService.AGG_LAST = 'last';\n  AggFuncService.AGG_MIN = 'min';\n  AggFuncService.AGG_MAX = 'max';\n  AggFuncService.AGG_COUNT = 'count';\n  AggFuncService.AGG_AVG = 'avg';\n\n  __decorate([ag_grid_community_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)], AggFuncService.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([ag_grid_community_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], AggFuncService.prototype, \"init\", null);\n\n  AggFuncService = AggFuncService_1 = __decorate([ag_grid_community_1.Bean('aggFuncService')], AggFuncService);\n  return AggFuncService;\n}();\n\nexports.AggFuncService = AggFuncService;\n\nfunction aggSum(input) {\n  var result = null;\n  var length = input.length;\n\n  for (var i = 0; i < length; i++) {\n    if (typeof input[i] === 'number') {\n      if (result === null) {\n        result = input[i];\n      } else {\n        result += input[i];\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction aggFirst(input) {\n  if (input.length >= 0) {\n    return input[0];\n  } else {\n    return null;\n  }\n}\n\nfunction aggLast(input) {\n  if (input.length >= 0) {\n    return input[input.length - 1];\n  } else {\n    return null;\n  }\n}\n\nfunction aggMin(input) {\n  var result = null;\n  var length = input.length;\n\n  for (var i = 0; i < length; i++) {\n    if (typeof input[i] === 'number') {\n      if (result === null) {\n        result = input[i];\n      } else if (result > input[i]) {\n        result = input[i];\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction aggMax(input) {\n  var result = null;\n  var length = input.length;\n\n  for (var i = 0; i < length; i++) {\n    if (typeof input[i] === 'number') {\n      if (result === null) {\n        result = input[i];\n      } else if (result < input[i]) {\n        result = input[i];\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction aggCount(input) {\n  var result = {\n    value: 0,\n    toString: function toString() {\n      return this.value.toString();\n    },\n    // used for sorting\n    toNumber: function toNumber() {\n      return this.value;\n    }\n  };\n  var length = input.length;\n\n  for (var i = 0; i < length; i++) {\n    var isGroupAgg = ag_grid_community_1._.exists(input[i]) && typeof input[i].value === 'number';\n\n    if (isGroupAgg) {\n      result.value += input[i].value;\n    } else {\n      result.value++;\n    }\n  }\n\n  return result;\n} // the average function is tricky as the multiple levels require weighted averages\n// for the non-leaf node aggregations.\n\n\nfunction aggAvg(input) {\n  // the average will be the sum / count\n  var sum = 0;\n  var count = 0;\n  var length = input.length;\n\n  for (var i = 0; i < length; i++) {\n    var currentItem = input[i];\n    var itemIsGroupResult = ag_grid_community_1._.exists(currentItem) && typeof currentItem.value === 'number' && typeof currentItem.count === 'number'; // skip values that are not numbers (ie skip empty values)\n\n    if (typeof currentItem === 'number') {\n      sum += currentItem;\n      count++; // check if it's a group (ie value is a wrapper object)\n    } else if (itemIsGroupResult) {\n      // we are aggregating groups, so we take the\n      // aggregated values to calculated a weighted average\n      sum += currentItem.value * currentItem.count;\n      count += currentItem.count;\n    }\n  } // avoid divide by zero error\n\n\n  var value = null;\n\n  if (count !== 0) {\n    value = sum / count;\n  } // the result will be an object. when this cell is rendered, only the avg is shown.\n  // however when this cell is part of another aggregation, the count is also needed\n  // to create a weighted average for the next level.\n\n\n  var result = {\n    count: count,\n    value: value,\n    // the grid by default uses toString to render values for an object, so this\n    // is a trick to get the default cellRenderer to display the avg value\n    toString: function toString() {\n      if (typeof this.value === 'number') {\n        return this.value.toString();\n      } else {\n        return '';\n      }\n    },\n    // used for sorting\n    toNumber: function toNumber() {\n      return this.value;\n    }\n  };\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}