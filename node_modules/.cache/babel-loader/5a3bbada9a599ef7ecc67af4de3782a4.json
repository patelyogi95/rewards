{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore Suppress tsc error: Property 'sign' does not exist on type 'Math'\n\nvar sign = Math.sign ? Math.sign : function (x) {\n  x = +x;\n\n  if (x === 0 || isNaN(x)) {\n    return x;\n  }\n\n  return x > 0 ? 1 : -1;\n};\n/**\n * Finds the roots of a parametric linear equation in `t`,\n * where `t` lies in the interval of `[0,1]`.\n */\n\nfunction linearRoot(a, b) {\n  var t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\n\nexports.linearRoot = linearRoot;\n/**\n * Finds the roots of a parametric quadratic equation in `t`,\n * where `t` lies in the interval of `[0,1]`.\n */\n\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n\n  var D = b * b - 4 * a * c; // The polynomial's discriminant.\n\n  var roots = [];\n\n  if (D === 0) {\n    // A single real root.\n    var t = -b / (2 * a);\n\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    // A pair of distinct real roots.\n    var rD = Math.sqrt(D);\n    var t1 = (-b - rD) / (2 * a);\n    var t2 = (-b + rD) / (2 * a);\n\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  } // else -> Complex roots.\n\n\n  return roots;\n}\n\nexports.quadraticRoots = quadraticRoots;\n/**\n * Finds the roots of a parametric cubic equation in `t`,\n * where `t` lies in the interval of `[0,1]`.\n * Returns an array of parametric intersection locations along the cubic,\n * excluding out-of-bounds intersections (before or after the end point\n * or in the imaginary plane).\n * An adaptation of http://www.particleincell.com/blog/2013/cubic-line-intersection/\n */\n\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n\n  var A = b / a;\n  var B = c / a;\n  var C = d / a;\n  var Q = (3 * B - A * A) / 9;\n  var R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  var D = Q * Q * Q + R * R; // The polynomial's discriminant.\n\n  var third = 1 / 3;\n  var roots = [];\n\n  if (D >= 0) {\n    // Complex or duplicate roots.\n    var rD = Math.sqrt(D);\n    var S = sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    var T = sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    var Im = Math.abs(Math.sqrt(3) * (S - T) / 2); // Complex part of the root pair.\n\n    var t = -third * A + (S + T); // A real root.\n\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n\n    if (Im === 0) {\n      var t_1 = -third * A - (S + T) / 2; // The real part of a complex root.\n\n      if (t_1 >= 0 && t_1 <= 1) {\n        roots.push(t_1);\n      }\n    }\n  } else {\n    // Distinct real roots.\n    var theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    var thirdA = third * A;\n    var twoSqrtQ = 2 * Math.sqrt(-Q);\n    var t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    var t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    var t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n\n  return roots;\n}\n\nexports.cubicRoots = cubicRoots;","map":null,"metadata":{},"sourceType":"script"}