{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar node_1 = require(\"../node\");\n\nvar object_1 = require(\"../../util/object\");\n\nvar Shape =\n/** @class */\nfunction (_super) {\n  __extends(Shape, _super);\n\n  function Shape() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._fillStyle = Shape.defaultStyles.fillStyle; //| CanvasGradient | CanvasPattern;\n\n    /**\n     * Note that `strokeStyle = null` means invisible stroke,\n     * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\n     * For example, a rect shape with an invisible stroke may not align to the pixel grid\n     * properly because the stroke affects the rules of alignment, and arc shapes forming\n     * a pie chart will have a gap between them if they have an invisible stroke, whereas\n     * there would be not gap if there was no stroke at all.\n     * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\n     * unless specific looks that is achieved by having an invisible stroke is desired.\n     */\n\n    _this._strokeStyle = Shape.defaultStyles.strokeStyle;\n    _this._lineWidth = Shape.defaultStyles.lineWidth;\n    _this._lineDash = Shape.defaultStyles.lineDash;\n    _this._lineDashOffset = Shape.defaultStyles.lineDashOffset;\n    _this._lineCap = Shape.defaultStyles.lineCap;\n    _this._lineJoin = Shape.defaultStyles.lineJoin;\n    _this._opacity = Shape.defaultStyles.opacity;\n    _this._shadow = Shape.defaultStyles.shadow;\n    return _this;\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n\n\n  Shape.prototype.restoreOwnStyles = function () {\n    var styles = this.constructor.defaultStyles;\n    var keys = Object.getOwnPropertyNames(styles); // getOwnPropertyNames is about 2.5 times faster than\n    // for..in with the hasOwnProperty check and in this\n    // case, where most properties are inherited, can be\n    // more then an order of magnitude faster.\n\n    for (var i = 0, n = keys.length; i < n; i++) {\n      var key = keys[i];\n      this[key] = styles[key];\n    }\n  };\n\n  Shape.prototype.restoreAllStyles = function () {\n    var styles = this.constructor.defaultStyles;\n\n    for (var property in styles) {\n      this[property] = styles[property];\n    }\n  };\n  /**\n   * Restores the base class default styles that have been overridden by this subclass.\n   */\n\n\n  Shape.prototype.restoreOverriddenStyles = function () {\n    var styles = this.constructor.defaultStyles;\n    var protoStyles = Object.getPrototypeOf(styles);\n\n    for (var property in styles) {\n      if (styles.hasOwnProperty(property) && protoStyles.hasOwnProperty(property)) {\n        this[property] = styles[property];\n      }\n    }\n  };\n\n  Object.defineProperty(Shape.prototype, \"fillStyle\", {\n    get: function get() {\n      return this._fillStyle;\n    },\n    set: function set(value) {\n      if (this._fillStyle !== value) {\n        this._fillStyle = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"strokeStyle\", {\n    get: function get() {\n      return this._strokeStyle;\n    },\n    set: function set(value) {\n      if (this._strokeStyle !== value) {\n        this._strokeStyle = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"lineWidth\", {\n    get: function get() {\n      return this._lineWidth;\n    },\n    set: function set(value) {\n      if (this._lineWidth !== value) {\n        this._lineWidth = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"lineDash\", {\n    get: function get() {\n      return this._lineDash;\n    },\n    set: function set(value) {\n      var oldValue = this._lineDash;\n\n      if (oldValue !== value) {\n        if (oldValue && value && oldValue.length === value.length) {\n          var identical = true;\n          var n = value.length;\n\n          for (var i = 0; i < n; i++) {\n            if (oldValue[i] !== value[i]) {\n              identical = false;\n              break;\n            }\n          }\n\n          if (identical) {\n            return;\n          }\n        }\n\n        this._lineDash = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"lineDashOffset\", {\n    get: function get() {\n      return this._lineDashOffset;\n    },\n    set: function set(value) {\n      if (this._lineDashOffset !== value) {\n        this._lineDashOffset = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"lineCap\", {\n    get: function get() {\n      return this._lineCap;\n    },\n    set: function set(value) {\n      if (this._lineCap !== value) {\n        this._lineCap = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"lineJoin\", {\n    get: function get() {\n      return this._lineJoin;\n    },\n    set: function set(value) {\n      if (this._lineJoin !== value) {\n        this._lineJoin = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"opacity\", {\n    get: function get() {\n      return this._opacity;\n    },\n    set: function set(value) {\n      value = Math.min(1, Math.max(0, value));\n\n      if (this._opacity !== value) {\n        this._opacity = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Shape.prototype, \"shadow\", {\n    get: function get() {\n      return this._shadow;\n    },\n    set: function set(value) {\n      if (this._shadow !== value) {\n        this._shadow = value;\n        this.dirty = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Shape.prototype.applyContextAttributes = function (ctx) {\n    if (this.fillStyle) {\n      ctx.fillStyle = this.fillStyle;\n    }\n\n    if (this.strokeStyle) {\n      ctx.strokeStyle = this.strokeStyle;\n      ctx.lineWidth = this.lineWidth;\n\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n    }\n\n    if (this.opacity < 1) {\n      ctx.globalAlpha = this.opacity;\n    }\n\n    var shadow = this.shadow;\n\n    if (shadow) {\n      ctx.shadowColor = shadow.color;\n      ctx.shadowOffsetX = shadow.offset.x;\n      ctx.shadowOffsetY = shadow.offset.y;\n      ctx.shadowBlur = shadow.blur;\n    }\n  };\n\n  Shape.prototype.isPointInNode = function (x, y) {\n    return this.isPointInPath(x, y);\n  };\n  /**\n   * Defaults for style properties. Note that properties that affect the position\n   * and shape of the node are not considered style properties, for example:\n   * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n   * Can be used to reset to the original styling after some custom styling\n   * has been applied (using the `restoreOwnStyles` and `restoreAllStyles` methods).\n   * These static defaults are meant to be inherited by subclasses.\n   */\n\n\n  Shape.defaultStyles = object_1.chainObjects({}, {\n    fillStyle: 'black',\n    strokeStyle: null,\n    lineWidth: 0,\n    lineDash: null,\n    lineDashOffset: 0,\n    lineCap: null,\n    lineJoin: null,\n    opacity: 1,\n    shadow: null\n  });\n  return Shape;\n}(node_1.Node);\n\nexports.Shape = Shape;","map":null,"metadata":{},"sourceType":"script"}