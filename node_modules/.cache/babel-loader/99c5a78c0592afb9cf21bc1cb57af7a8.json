{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar continuousScale_1 = require(\"./continuousScale\");\n\nvar compare_1 = require(\"../util/compare\");\n\nvar ticks_1 = require(\"../util/ticks\");\n/**\n * Maps continuous domain to a continuous range.\n */\n\n\nvar LinearScale =\n/** @class */\nfunction (_super) {\n  __extends(LinearScale, _super);\n\n  function LinearScale() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LinearScale.prototype.deinterpolatorOf = function (a, b) {\n    var d = b - a;\n\n    if (d === 0 || isNaN(d)) {\n      return function () {\n        return d;\n      };\n    } else {\n      return function (x) {\n        return (x - a) / d;\n      };\n    }\n  };\n\n  LinearScale.prototype.reinterpolatorOf = function (a, b) {\n    var d = b - a;\n    return function (t) {\n      return a + d * t;\n    };\n  };\n\n  LinearScale.prototype.ticks = function (count) {\n    if (count === void 0) {\n      count = 10;\n    }\n\n    var d = this._domain;\n    return ticks_1.default(d[0], d[d.length - 1], count);\n  };\n\n  return LinearScale;\n}(continuousScale_1.default);\n\nexports.LinearScale = LinearScale;\n\nfunction reinterpolateNumber(a, b) {\n  var d = b - a;\n  return function (t) {\n    return a + d * t;\n  };\n}\n\nexports.reinterpolateNumber = reinterpolateNumber;\n\nfunction deinterpolateNumber(a, b) {\n  var d = b - a;\n\n  if (d === 0 || isNaN(d)) {\n    return function () {\n      return d;\n    };\n  } else {\n    return function (x) {\n      return (x - a) / d;\n    };\n  }\n}\n\nexports.deinterpolateNumber = deinterpolateNumber;\n/**\n * Creates a continuous scale with the default interpolator and no clamping.\n */\n\nfunction scaleLinear() {\n  var scale = new LinearScale(reinterpolateNumber, deinterpolateNumber, compare_1.naturalOrder);\n  scale.range = [0, 1];\n  return scale;\n}\n\nexports.default = scaleLinear;","map":null,"metadata":{},"sourceType":"script"}