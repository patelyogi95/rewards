{"ast":null,"code":"// ag-grid-enterprise v20.2.0\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar intersection_1 = require(\"./intersection\");\n\nvar Path2D =\n/** @class */\nfunction () {\n  function Path2D() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.commands = [];\n    this.params = [];\n  }\n\n  Path2D.prototype.moveTo = function (x, y) {\n    if (this.xy) {\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.xy = [x, y];\n    }\n\n    this.commands.push('M');\n    this.params.push(x, y);\n  };\n\n  Path2D.prototype.lineTo = function (x, y) {\n    if (this.xy) {\n      this.commands.push('L');\n      this.params.push(x, y);\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n\n  Path2D.prototype.rect = function (x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  };\n  /**\n   * Adds an arc segment to the path definition.\n   * https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands\n   * @param rx The major-axis radius.\n   * @param ry The minor-axis radius.\n   * @param rotation The x-axis rotation, expressed in radians.\n   * @param fA The large arc flag. `1` to use angle > π.\n   * @param fS The sweep flag. `1` for the arc that goes to `x`/`y` clockwise.\n   * @param x2 The x coordinate to arc to.\n   * @param y2 The y coordinate to arc to.\n   */\n\n\n  Path2D.prototype.arcTo = function (rx, ry, rotation, fA, fS, x2, y2) {\n    // Convert from endpoint to center parametrization:\n    // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n    var xy = this.xy;\n    if (!xy) return;\n\n    if (rx < 0) {\n      rx = -rx;\n    }\n\n    if (ry < 0) {\n      ry = -ry;\n    }\n\n    var x1 = xy[0];\n    var y1 = xy[1];\n    var hdx = (x1 - x2) / 2;\n    var hdy = (y1 - y2) / 2;\n    var sinPhi = Math.sin(rotation);\n    var cosPhi = Math.cos(rotation);\n    var xp = cosPhi * hdx + sinPhi * hdy;\n    var yp = -sinPhi * hdx + cosPhi * hdy;\n    var ratX = xp / rx;\n    var ratY = yp / ry;\n    var lambda = ratX * ratX + ratY * ratY;\n    var cx = (x1 + x2) / 2;\n    var cy = (y1 + y2) / 2;\n    var cpx = 0;\n    var cpy = 0;\n\n    if (lambda >= 1) {\n      lambda = Math.sqrt(lambda);\n      rx *= lambda;\n      ry *= lambda; // me gives lambda == cpx == cpy == 0;\n    } else {\n      lambda = Math.sqrt(1 / lambda - 1);\n\n      if (fA === fS) {\n        lambda = -lambda;\n      }\n\n      cpx = lambda * rx * ratY;\n      cpy = -lambda * ry * ratX;\n      cx += cosPhi * cpx - sinPhi * cpy;\n      cy += sinPhi * cpx + cosPhi * cpy;\n    }\n\n    var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx);\n    var deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1; // if (fS) {\n    //     if (deltaTheta <= 0) {\n    //         deltaTheta += Math.PI * 2;\n    //     }\n    // }\n    // else {\n    //     if (deltaTheta >= 0) {\n    //         deltaTheta -= Math.PI * 2;\n    //     }\n    // }\n\n    this.cubicArc(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);\n  };\n\n  Path2D.prototype.arcToAlt = function (rx, ry, rotation, fA, fS, x2, y2) {\n    // Convert from endpoint to center parametrization. See:\n    // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n    if (!this.xy) return;\n\n    if (rx < 0) {\n      rx = -rx;\n    }\n\n    if (ry < 0) {\n      ry = -ry;\n    }\n\n    var x1 = this.xy[0];\n    var y1 = this.xy[1];\n    var hdx = (x1 - x2) / 2;\n    var hdy = (y1 - y2) / 2;\n    var sinPhi = Math.sin(rotation);\n    var cosPhi = Math.cos(rotation);\n    var x1p = cosPhi * hdx + sinPhi * hdy;\n    var y1p = -sinPhi * hdx + cosPhi * hdy;\n    var rx_y1p = rx * rx * y1p * y1p;\n    var ry_x1p = ry * ry * x1p * x1p;\n    var root = Math.sqrt((rx * rx * ry * ry - rx_y1p - ry_x1p) / (rx_y1p + ry_x1p));\n    var rootSign = fA === fS ? 0 : 1;\n    var cxp = rootSign * root * rx * y1p / ry;\n    var cyp = -rootSign * root * ry * x1p / rx;\n    var cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;\n    var cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;\n    var theta1 = Math.acos((x1p - cxp) / rx / ((x1p - cxp) / rx));\n  };\n  /**\n   * Approximates an elliptical arc with up to four cubic Bézier curves.\n   * @param commands The string array to write SVG command letters to.\n   * @param params The number array to write SVG command parameters (cubic control points) to.\n   * @param cx The x-axis coordinate for the ellipse's center.\n   * @param cy The y-axis coordinate for the ellipse's center.\n   * @param rx The ellipse's major-axis radius.\n   * @param ry The ellipse's minor-axis radius.\n   * @param phi The rotation for this ellipse, expressed in radians.\n   * @param theta1 The starting angle, measured clockwise from the positive x-axis and expressed in radians.\n   * @param theta2 The ending angle, measured clockwise from the positive x-axis and expressed in radians.\n   * @param anticlockwise The arc control points are always placed clockwise from `theta1` to `theta2`,\n   * even when `theta1 > theta2`, unless this flag is set to `1`.\n   */\n\n\n  Path2D.cubicArc = function (commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n    if (anticlockwise) {\n      var temp = theta1;\n      theta1 = theta2;\n      theta2 = temp;\n    }\n\n    var start = params.length; // See https://pomax.github.io/bezierinfo/#circles_cubic\n    // Arc of unit circle (start angle = 0, end angle <= π/2) in cubic Bézier coordinates:\n    // S = [1, 0]\n    // C1 = [1, f]\n    // C2 = [cos(θ) + f * sin(θ), sin(θ) - f * cos(θ)]\n    // E = [cos(θ), sin(θ)]\n    // f = 4/3 * tan(θ/4)\n\n    var f90 = 0.5522847498307935; // f for θ = π/2 is 4/3 * (Math.sqrt(2) - 1)\n\n    var sinTheta1 = Math.sin(theta1);\n    var cosTheta1 = Math.cos(theta1);\n    var sinPhi = Math.sin(phi);\n    var cosPhi = Math.cos(phi);\n    var rightAngle = Math.PI / 2; // Since we know how to draw an arc of a unit circle with a cubic Bézier,\n    // to draw an elliptical arc with arbitrary rotation and radii we:\n    // 1) rotate the Bézier coordinates that represent a circular arc by θ\n    // 2) scale the circular arc separately along the x/y axes, making it elliptical\n    // 3) rotate elliptical arc by φ\n    // |cos(φ) -sin(φ)| |sx  0| |cos(θ) -sin(θ)| -> |xx xy|\n    // |sin(φ)  cos(φ)| | 0 sy| |sin(θ)  cos(θ)| -> |yx yy|\n\n    var xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry;\n    var yx = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry;\n    var xy = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry;\n    var yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry; // TODO: what if delta between θ1 and θ2 is greater than 2π?\n    // Always draw clockwise from θ1 to θ2.\n\n    theta2 -= theta1;\n\n    if (theta2 < 0) {\n      theta2 += Math.PI * 2;\n    } // Multiplying each point [x, y] by:\n    // |xx xy cx| |x|\n    // |yx yy cy| |y|\n    // | 0  0  1| |1|\n    // TODO: This move command may be redundant, if we are already at this point.\n    // The coordinates of the point calculated here may differ ever so slightly\n    // because of precision error.\n\n\n    commands.push('M');\n    params.push(xx + cx, yx + cy);\n\n    while (theta2 >= rightAngle) {\n      theta2 -= rightAngle;\n      commands.push('C');\n      params.push(xx + xy * f90 + cx, yx + yy * f90 + cy, xx * f90 + xy + cx, yx * f90 + yy + cy, xy + cx, yy + cy); // Prepend π/2 rotation matrix.\n      // |xx xy| | 0 1| -> | xy -xx|\n      // |yx yy| |-1 0| -> | yy -yx|\n      // [xx, yx, xy, yy] = [xy, yy, -xx, -yx];\n      // Compared to swapping with a temp variable, destructuring is:\n      // - 10% faster in Chrome 70\n      // - 99% slower in Firefox 63\n      // Temp variable solution is 45% faster in FF than Chrome.\n      // https://jsperf.com/multi-swap\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1165569\n\n      var temp = xx;\n      xx = xy;\n      xy = -temp;\n      temp = yx;\n      yx = yy;\n      yy = -temp;\n    }\n\n    if (theta2) {\n      var f = 4 / 3 * Math.tan(theta2 / 4);\n      var sinPhi2 = Math.sin(theta2);\n      var cosPhi2 = Math.cos(theta2);\n      var C2x = cosPhi2 + f * sinPhi2;\n      var C2y = sinPhi2 - f * cosPhi2;\n      commands.push('C');\n      params.push(xx + xy * f + cx, yx + yy * f + cy, xx * C2x + xy * C2y + cx, yx * C2x + yy * C2y + cy, xx * cosPhi2 + xy * sinPhi2 + cx, yx * cosPhi2 + yy * sinPhi2 + cy);\n    }\n\n    if (anticlockwise) {\n      for (var i = start, j = params.length - 2; i < j; i += 2, j -= 2) {\n        var temp = params[i];\n        params[i] = params[j];\n        params[j] = temp;\n        temp = params[i + 1];\n        params[i + 1] = params[j + 1];\n        params[j + 1] = temp;\n      }\n    }\n  };\n\n  Path2D.prototype.cubicArc = function (cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n    var commands = this.commands;\n    var params = this.params;\n    var start = commands.length;\n    Path2D.cubicArc(commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise);\n    var x = params[params.length - 2];\n    var y = params[params.length - 1];\n\n    if (this.xy) {\n      commands[start] = 'L';\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.xy = [x, y];\n    }\n  };\n  /**\n   * Returns the `[x, y]` coordinates of the curve at `t`.\n   * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n   * @param t\n   */\n\n\n  Path2D.prototype.deCasteljau = function (points, t) {\n    var n = points.length;\n\n    if (n < 2 || n % 2 === 1) {\n      throw new Error('Fewer than two points or not an even count.');\n    } else if (n === 2 || t === 0) {\n      return points.slice(0, 2);\n    } else if (t === 1) {\n      return points.slice(-2);\n    } else {\n      var newPoints = [];\n      var last = n - 2;\n\n      for (var i = 0; i < last; i += 2) {\n        newPoints.push((1 - t) * points[i] + t * points[i + 2], // x\n        (1 - t) * points[i + 1] + t * points[i + 3] // y\n        );\n      }\n\n      return this.deCasteljau(newPoints, t);\n    }\n  };\n  /**\n   * Approximates the given curve using `n` line segments.\n   * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n   * @param n\n   */\n\n\n  Path2D.prototype.approximateCurve = function (points, n) {\n    var xy = this.deCasteljau(points, 0);\n    this.moveTo(xy[0], xy[1]);\n    var step = 1 / n;\n\n    for (var t = step; t <= 1; t += step) {\n      var xy_1 = this.deCasteljau(points, t);\n      this.lineTo(xy_1[0], xy_1[1]);\n    }\n  };\n  /**\n   * Adds a quadratic curve segment to the path definition.\n   * Note: the given quadratic segment is converted and stored as a cubic one.\n   * @param cx x-component of the curve's control point\n   * @param cy y-component of the curve's control point\n   * @param x x-component of the end point\n   * @param y y-component of the end point\n   */\n\n\n  Path2D.prototype.quadraticCurveTo = function (cx, cy, x, y) {\n    if (!this.xy) {\n      this.moveTo(cx, cy);\n    } // See https://pomax.github.io/bezierinfo/#reordering\n\n\n    this.cubicCurveTo((this.xy[0] + 2 * cx) / 3, (this.xy[1] + 2 * cy) / 3, // 1/3 start + 2/3 control\n    (2 * cx + x) / 3, (2 * cy + y) / 3, // 2/3 control + 1/3 end\n    x, y);\n  };\n\n  Path2D.prototype.cubicCurveTo = function (cx1, cy1, cx2, cy2, x, y) {\n    if (!this.xy) {\n      this.moveTo(cx1, cy1);\n    }\n\n    this.commands.push('C');\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n    this.xy[0] = x;\n    this.xy[1] = y;\n  };\n\n  Path2D.prototype.closePath = function () {\n    if (this.xy) {\n      this.xy = undefined;\n      this.commands.push('Z');\n    }\n  };\n\n  Path2D.prototype.clear = function () {\n    this.commands.length = 0;\n    this.params.length = 0;\n    this.xy = undefined;\n  };\n\n  Path2D.prototype.isPointInPath = function (x, y) {\n    var commands = this.commands;\n    var params = this.params;\n    var cn = commands.length; // Hit testing using ray casting method, where the ray's origin is some point\n    // outside the path. In this case, an offscreen point that is remote enough, so that\n    // even if the path itself is large and is partially offscreen, the ray's origin\n    // will likely be outside the path anyway. To test if the given point is inside the\n    // path or not, we cast a ray from the origin to the given point and check the number\n    // of intersections of this segment with the path. If the number of intersections is\n    // even, then the ray both entered and exited the path an equal number of times,\n    // therefore the point is outside the path, and inside the path, if the number of\n    // intersections is odd. Since the path is compound, we check if the ray segment\n    // intersects with each of the path's segments, which can be either a line segment\n    // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\n    // points).\n\n    var ox = -10000;\n    var oy = -10000; // the starting point of the  current path\n\n    var sx = NaN;\n    var sy = NaN; // the previous point of the current path\n\n    var px = 0;\n    var py = 0;\n    var intersectionCount = 0;\n\n    for (var ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 'M':\n          if (!isNaN(sx)) {\n            if (intersection_1.segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n              intersectionCount++;\n            }\n          }\n\n          sx = px = params[pi++];\n          sy = py = params[pi++];\n          break;\n\n        case 'L':\n          if (intersection_1.segmentIntersection(px, py, px = params[pi++], py = params[pi++], ox, oy, x, y)) {\n            intersectionCount++;\n          }\n\n          break;\n\n        case 'C':\n          intersectionCount += intersection_1.cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], px = params[pi++], py = params[pi++], ox, oy, x, y).length;\n          break;\n\n        case 'Z':\n          if (!isNaN(sx)) {\n            if (intersection_1.segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n              intersectionCount++;\n            }\n          }\n\n          break;\n      }\n    }\n\n    return intersectionCount % 2 === 1;\n  };\n\n  Path2D.fromString = function (value) {\n    var path = new Path2D();\n    path.setFromString(value);\n    return path;\n  };\n  /**\n   * Split the SVG path at command letters,\n   * then extract the command letter and parameters from each substring.\n   * @param value\n   */\n\n\n  Path2D.parseSvgPath = function (value) {\n    return value.trim().split(Path2D.splitCommandsRe).map(function (part) {\n      var strParams = part.match(Path2D.matchParamsRe);\n      return {\n        command: part.substr(0, 1),\n        params: strParams ? strParams.map(parseFloat) : []\n      };\n    });\n  };\n\n  Path2D.prettifySvgPath = function (value) {\n    return Path2D.parseSvgPath(value).map(function (d) {\n      return d.command + d.params.join(',');\n    }).join('\\n');\n  };\n  /**\n   * See https://www.w3.org/TR/SVG11/paths.html\n   * @param value\n   */\n\n\n  Path2D.prototype.setFromString = function (value) {\n    var _this = this;\n\n    this.clear();\n    var parts = Path2D.parseSvgPath(value); // Current point.\n\n    var x;\n    var y; // Last control point. Used to calculate the reflection point\n    // for `S`, `s`, `T`, `t` commands.\n\n    var cpx;\n    var cpy;\n    var lastCommand;\n\n    function checkQuadraticCP() {\n      if (!lastCommand.match(Path2D.quadraticCommandRe)) {\n        cpx = x;\n        cpy = y;\n      }\n    }\n\n    function checkCubicCP() {\n      if (!lastCommand.match(Path2D.cubicCommandRe)) {\n        cpx = x;\n        cpy = y;\n      }\n    } // TODO: use the regular for loop for better performance\n    // But that will make compiler complain about x/y, cpx/cpy\n    // being used without being set first.\n\n\n    parts.forEach(function (part) {\n      var p = part.params;\n      var n = p.length;\n      var i = 0;\n\n      switch (part.command) {\n        case 'M':\n          _this.moveTo(x = p[i++], y = p[i++]);\n\n          while (i < n) {\n            _this.lineTo(x = p[i++], y = p[i++]);\n          }\n\n          break;\n\n        case 'm':\n          _this.moveTo(x += p[i++], y += p[i++]);\n\n          while (i < n) {\n            _this.lineTo(x += p[i++], y += p[i++]);\n          }\n\n          break;\n\n        case 'L':\n          while (i < n) {\n            _this.lineTo(x = p[i++], y = p[i++]);\n          }\n\n          break;\n\n        case 'l':\n          while (i < n) {\n            _this.lineTo(x += p[i++], y += p[i++]);\n          }\n\n          break;\n\n        case 'C':\n          while (i < n) {\n            _this.cubicCurveTo(p[i++], p[i++], cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n          }\n\n          break;\n\n        case 'c':\n          while (i < n) {\n            _this.cubicCurveTo(x + p[i++], y + p[i++], cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n          }\n\n          break;\n\n        case 'S':\n          checkCubicCP();\n\n          while (i < n) {\n            _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n          }\n\n          break;\n\n        case 's':\n          checkCubicCP();\n\n          while (i < n) {\n            _this.cubicCurveTo(x + x - cpx, y + y - cpy, cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n          }\n\n          break;\n\n        case 'Q':\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = p[i++], cpy = p[i++], x = p[i++], y = p[i++]);\n          }\n\n          break;\n\n        case 'q':\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = x + p[i++], cpy = y + p[i++], x += p[i++], y += p[i++]);\n          }\n\n          break;\n\n        case 'T':\n          checkQuadraticCP();\n\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x = p[i++], y = p[i++]);\n          }\n\n          break;\n\n        case 't':\n          checkQuadraticCP();\n\n          while (i < n) {\n            _this.quadraticCurveTo(cpx = x + x - cpx, cpy = y + y - cpy, x += p[i++], y += p[i++]);\n          }\n\n          break;\n\n        case 'A':\n          while (i < n) {\n            _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x = p[i++], y = p[i++]);\n          }\n\n          break;\n\n        case 'a':\n          while (i < n) {\n            _this.arcTo(p[i++], p[i++], p[i++] * Math.PI / 180, p[i++], p[i++], x += p[i++], y += p[i++]);\n          }\n\n          break;\n\n        case 'Z':\n        case 'z':\n          _this.closePath();\n\n          break;\n\n        case 'H':\n          while (i < n) {\n            _this.lineTo(x = p[i++], y);\n          }\n\n          break;\n\n        case 'h':\n          while (i < n) {\n            _this.lineTo(x += p[i++], y);\n          }\n\n          break;\n\n        case 'V':\n          while (i < n) {\n            _this.lineTo(x, y = p[i++]);\n          }\n\n          break;\n\n        case 'v':\n          while (i < n) {\n            _this.lineTo(x, y += p[i++]);\n          }\n\n          break;\n      }\n\n      lastCommand = part.command;\n    });\n  };\n\n  Path2D.prototype.toString = function () {\n    var c = this.commands;\n    var p = this.params;\n    var cn = c.length;\n    var out = [];\n\n    for (var ci = 0, pi = 0; ci < cn; ci++) {\n      switch (c[ci]) {\n        case 'M':\n          out.push('M' + p[pi++] + ',' + p[pi++]);\n          break;\n\n        case 'L':\n          out.push('L' + p[pi++] + ',' + p[pi++]);\n          break;\n\n        case 'C':\n          out.push('C' + p[pi++] + ',' + p[pi++] + ' ' + p[pi++] + ',' + p[pi++] + ' ' + p[pi++] + ',' + p[pi++]);\n          break;\n\n        case 'Z':\n          out.push('Z');\n          break;\n      }\n    }\n\n    return out.join('');\n  };\n\n  Path2D.prototype.toPrettyString = function () {\n    return Path2D.prettifySvgPath(this.toString());\n  };\n\n  Path2D.prototype.toSvg = function () {\n    return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 50\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + this.toString() + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n  };\n\n  Path2D.prototype.toDebugSvg = function () {\n    var d = Path2D.prettifySvgPath(this.toString());\n    return Path2D.xmlDeclaration + \"\\n<svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 100 100\\\" version=\\\"1.1\\\" xmlns=\\\"\" + Path2D.xmlns + \"\\\">\\n    <path d=\\\"\" + d + \"\\\" style=\\\"fill:none;stroke:#000;stroke-width:0.5;\\\"/>\\n</svg>\";\n  };\n  /**\n   * Returns an array of sub-paths of this Path,\n   * where each sub-path is represented exclusively by cubic segments.\n   */\n\n\n  Path2D.prototype.toCubicPaths = function () {\n    // Each sub-path is an array of `(n * 3 + 1) * 2` numbers,\n    // where `n` is the number of segments.\n    var paths = [];\n    var params = this.params; // current path\n\n    var path; // the starting point of the  current path\n\n    var sx;\n    var sy; // the previous point of the current path\n\n    var px;\n    var py;\n    var i = 0; // current parameter\n\n    this.commands.forEach(function (command) {\n      switch (command) {\n        case 'M':\n          path = [sx = px = params[i++], sy = py = params[i++]];\n          paths.push(path);\n          break;\n\n        case 'L':\n          var x = params[i++];\n          var y = params[i++]; // Place control points along the line `a + (b - a) * t`\n          // at t = 1/3 and 2/3:\n\n          path.push((px + px + x) / 3, (py + py + y) / 3, (px + x + x) / 3, (py + y + y) / 3, px = x, py = y);\n          break;\n\n        case 'C':\n          path.push(params[i++], params[i++], params[i++], params[i++], px = params[i++], py = params[i++]);\n          break;\n\n        case 'Z':\n          path.push((px + px + sx) / 3, (py + py + sy) / 3, (px + sx + sx) / 3, (py + sy + sy) / 3, px = sx, py = sy);\n          break;\n      }\n    });\n    return paths;\n  };\n\n  Path2D.cubicPathToString = function (path) {\n    var n = path.length;\n\n    if (!(n % 2 === 0 && (n / 2 - 1) / 2 >= 1)) {\n      throw new Error('Invalid path.');\n    }\n\n    return 'M' + path.slice(0, 2).join(',') + 'C' + path.slice(2).join(',');\n  };\n  /**\n   * The number of parameters for each of the SVG path commands.\n   */\n\n\n  Path2D.paramCounts = {\n    A: 7,\n    C: 6,\n    H: 1,\n    L: 2,\n    M: 2,\n    Q: 4,\n    S: 4,\n    T: 2,\n    V: 1,\n    Z: 0,\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0\n  };\n  Path2D.splitCommandsRe = /(?=[AaCcHhLlMmQqSsTtVvZz])/g;\n  Path2D.matchParamsRe = /-?[0-9]*\\.?\\d+/g;\n  Path2D.quadraticCommandRe = /[QqTt]/;\n  Path2D.cubicCommandRe = /[CcSs]/;\n  Path2D.xmlDeclaration = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n  Path2D.xmlns = 'http://www.w3.org/2000/svg';\n  return Path2D;\n}();\n\nexports.Path2D = Path2D;","map":null,"metadata":{},"sourceType":"script"}